package com.cypay.common.config;

import java.net.URL;
import java.net.URLConnection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.cypay.common.enums.AuthorizePermissions;
import com.cypay.common.enums.Edition;
import com.cypay.common.enums.PaymentType;

import cn.hutool.core.collection.ConcurrentHashSet;
import cn.hutool.core.date.DateUtil;
import cn.hutool.crypto.SecureUtil;
import cn.hutool.json.JSONUtil;

public class SystemAuthorize {
	
	private static Map<String, BiConsumer<String, Object>> handlers = new ConcurrentHashMap<>();
	
	private static Set<String> permissions = new ConcurrentHashSet<String>();
	
	static {
		// 支付宝代付
		handlers.put("A", (k, v) -> {
			Edition.current_edition.setPayeeAlipay("1".equals(v));
			if ("1".equals(v)) {
				permissions.add(AuthorizePermissions.PAYEE_ALIPAY.of());
			}
		});
		// 微信代付
		handlers.put("W", (k, v) -> {
			Edition.current_edition.setPayeeWechat("1".equals(v));
			if ("1".equals(v)) {
				permissions.add(AuthorizePermissions.PAYEE_WECHAT.of());
			}
		});
		// 个人版最大商户注册数
		handlers.put("N", (k, v) -> {
			int n = Integer.valueOf(v.toString());
			Edition.current_edition.setMax_allowed_regist_number(n > 0 ? n : 10);
		});
		// 授权网关
		handlers.put("B", (k, v) -> {
			String b = v.toString();
			Edition.current_edition.setSql(b.indexOf("0") != -1); // 通用网关
			if (b.indexOf("0") != -1) {
				permissions.add(AuthorizePermissions.GATEWAY_SQL.of());
			}
			Edition.current_edition.setCq(b.indexOf("1") != -1); // 传奇
			if (b.indexOf("1") != -1) {
				permissions.add(AuthorizePermissions.GATEWAY_CQ.of());
			}
			Edition.current_edition.setCs(b.indexOf("2") != -1); // 传世
			if (b.indexOf("2") != -1) {
				permissions.add(AuthorizePermissions.GATEWAY_CS.of());
			}
			Edition.current_edition.setCq3(b.indexOf("3") != -1); // 传奇三
			if (b.indexOf("3") != -1) {
				permissions.add(AuthorizePermissions.GATEWAY_CQ3.of());
			}
			Edition.current_edition.setWeb(b.indexOf("4") != -1); // web
			if (b.indexOf("4") != -1) {
				permissions.add(AuthorizePermissions.GATEWAY_WEB.of());
			}
		});
		// 授权通道
		handlers.put("G", (k, v) -> {
			Edition.current_edition.setOauth_gallerys(v);
			String count = k.replace("G", "");
			if (!"".equals(count)) {
				int i = Integer.valueOf(count);
				Edition.current_edition.setGalleryCount(i < 1 ? 1 : i);
			} else {
				Edition.current_edition.setGalleryCount(-1); // 不限制通道个数
			}
			oAuthGallery(v);
		});
	}
	
	private Logger logger = LoggerFactory.getLogger(this.getClass());
	
	public static final String AES_KEY = "c34a315844944c6da979a201dac0425e";
	
	public static final String MD5_KEY = "66ee9dd09f5647fbac9d4e9eb6081fa1";
	
	private JSONObject data;
	
	private Boolean pass = Boolean.FALSE;
	
	private Long expirationDate;
	
	public boolean parse(String ip, String token) {
		try {
			this.decryptToken(ip, token);
			
			this.signVerify();
			
			this.checkTime();
			
			this.parseVersion();
			
			this.parseData();
		} catch (Exception e) {
			this.pass = false;
		}
		
		if (!this.pass) {
			logger.info("【授权】授权信息验证未通过！");
			permissions.clear();
			Edition.current_edition = Edition.DEFAULT;
		}
		return this.pass;
	}
	
	/**
	 * Token解密
	 * @param ip
	 * @param token
	 */
	private void decryptToken(String ip, String token) {
		// 对IP进行MD5签名生成AES解密密钥
		String key = SecureUtil.md5(String.format("%s@%s", ip, AES_KEY));
		// 解密token信息
		String data = SecureUtil.aes(key.getBytes()).decryptStr(token.split("\\.")[0]);
		this.data = JSON.parseObject(data);
	}
	
	private void signVerify() {
		Object sign = this.data.remove("S");
		if (sign.equals(SecureUtil.md5(String.format("%s@@%s", this.data.toJSONString(), MD5_KEY)))) {
			logger.info("【授权】签名验证通过，获取授权信息！");
			this.pass = true;
			return;
		}
		logger.info("【授权】签名验证未通过！");
		this.pass =  false;
	}
	
	/**
	 * 校验授权到期时间
	 */
	private void checkTime() {
		if (this.pass) {
			// 网络时间
			long curr_time = this.getNetworkTime();
			logger.info("【授权】获取当前时间：" + DateUtil.date(curr_time));
			// 授权到期时间
			long time = DateUtil.parse(this.data.getString("D"), "yyMMdd").getTime();
			logger.info("【授权】授权到期时间：" + DateUtil.date(time));
			if (time > curr_time) { // 检验系统过期时间
				this.expirationDate = time;
				this.pass = true;
				return;
			}
			this.pass = false;
			logger.info("【授权】授权已过期！");
		}
	}
	
	/**
	 * 获取授权版本
	 */
	private void parseVersion() {
		if (this.pass) {
			if ("1".equals(data.get("E"))) { // 商业版
				Edition.current_edition = Edition.BUSINESS.reset();
			} else { // 个人版
				Edition.current_edition = Edition.PERSONAL.reset();
			}
		}
	}
	
	/**
	 * 解析授权信息
	 */
	private void parseData() {
		if (this.pass) {
			permissions.clear();
			Edition.current_edition.setExpiration_date(this.expirationDate);
			this.data.keySet().parallelStream().forEach(key -> {
				BiConsumer<String, Object> handler = handlers.get(key.startsWith("G") ? "G" : key);
				Object value = this.data.get(key);
				if (handler != null && value != null) {
					handler.accept(key, value);
				}
			});
			this.pass = true;
			logger.info("【授权】SUCCESS！{}", Edition.current_edition);
		}
	}
	
	private static void oAuthGallery(Object obj) {
		InitialLoader.USABLE_GALLERY.clear();
		if ("1".equals(obj)) {
			// 添加所有通道至可用通道列表
			InitialLoader.USABLE_GALLERY.addAll(PaymentType.allGalleryMark());
		} else {
			try {
				// 添加已授权通道至可用通道列表
				InitialLoader.USABLE_GALLERY.addAll(PaymentType.dynamicAuthorMark(JSONUtil.parseArray(obj).toList(Integer.class)));
			} catch (Exception e) {}
			InitialLoader.USABLE_GALLERY.addAll(PaymentType.openGalleryMark());
		}
	}
	
	/**
	 * 获取网络时间
	 * @return
	 */
	private long getNetworkTime() {
		try {
			URL url = new URL("https://www.baidu.com");// 取得资源对象
			URLConnection uc = url.openConnection();// 生成连接对象
			uc.setReadTimeout(5000);// 设置访问超时时间 5s
			uc.connect();// 发出连接
			return uc.getDate();// 读取网站日期时间
		} catch (Exception e) {
			logger.error("【授权】Get network time exception!");
		}
		return 1285862400000L;
	}
	
	public static Set<String> permissions() {
		return permissions;
	}
}
