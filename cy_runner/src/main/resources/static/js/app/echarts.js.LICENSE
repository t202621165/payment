/***/

/* WEBPACK VAR INJECTION */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

// (1) The code `if (__DEV__) ...` can be removed by build tool.

// (2) If intend to use `__DEV__`, this module should be imported. Use a global

// variable `__DEV__` may cause that miss the declaration (see #6535), or the

// declaration is behind of the using position (for example in `Model.extent`,

// And tools like rollup can not analysis the dependency if not import).

// In browser

// Weixin Application

// Assume canvas is supported

// Zepto.js

// (c) 2010-2013 Thomas Fuchs

// Zepto.js may be freely distributed under the MIT license.

// Todo: clean this up with a better OS/browser seperation:

// - discern (more) between multiple browsers on android

// - decide if kindle fire in silk mode is android or not

// - Firefox on Android doesn't specify the Android version

// - possibly devide in os, device and browser hashes

// if (browser.webkit = !!webkit) browser.version = webkit[1];

// if (android) os.android = true, os.version = android[2];

// if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');

// if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');

// if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;

// if (webos) os.webos = true, os.version = webos[2];

// if (touchpad) os.touchpad = true;

// if (blackberry) os.blackberry = true, os.version = blackberry[2];

// if (bb10) os.bb10 = true, os.version = bb10[2];

// if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];

// if (playbook) browser.playbook = true;

// if (kindle) os.kindle = true, os.version = kindle[1];

// if (silk) browser.silk = true, browser.version = silk[1];

// if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;

// if (chrome) browser.chrome = true, browser.version = chrome[1];

// if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;

// if (webview) browser.webview = true;

// It is difficult to detect WeChat in Win Phone precisely, because ua can

// not be set on win phone. So we do not consider Win Phone.

// os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||

//     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));

// os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||

//     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||

//     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

// 原生canvas支持，改极端点了

// canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)

// works on most browsers

// IE10/11 does not support touch event, and MS Edge supports them but not by

// default, so we dont check navigator.maxTouchPoints for them here.

// <http://caniuse.com/#search=pointer%20event>.

// passiveSupported: detectPassiveSupport()

// See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection

// function detectPassiveSupport() {

//     // Test via a getter in the options object to see if the passive property is accessed

//     var supportsPassive = false;

//     try {

//         var opts = Object.defineProperty({}, 'passive', {

//             get: function() {

//                 supportsPassive = true;

//             }

//         });

//         window.addEventListener('testPassive', function() {}, opts);

//     } catch (e) {

//     }

//     return supportsPassive;

// }

/**
 * @module zrender/core/util
 */

// 用于处理merge时无法遍历Date等对象的问题

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */

// For node-canvas

// Clear ctx instance for different environment

/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */

/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */

// We should escapse that source is string

// and enter for ... in ...

// 否则只处理overwrite为true，或者在目标对象中没有此属性的情况

// NOTE，在 target[key] 不存在的时候也是直接覆盖

// 如果需要递归覆盖，就递归调用merge

/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */

/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */

/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */

// Use util.createCanvas instead of createCanvas

// because createCanvas may be overwritten in different environment

/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */

/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */

/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */

/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */

/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */

/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */

/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */

/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */

/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */

/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */

/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */

// Avoid a V8 JIT bug in Chrome 19-20.

// See https://code.google.com/p/v8/issues/detail?id=2291 for more details.

/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */

/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */

/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */

/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */

/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */

/**
 * @memberOf module:zrender/core/util
 * @param {string} str string to be trimed
 * @return {string} trimed string
 */

/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */

/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */

// Key should not be set on this, otherwise

// methods get/set/... may be overrided.

// Do not provide `has` method to avoid defining what is `has`.

// (We usually treat `null` and `undefined` as the same, different

// from ES6 Map).

// Comparing with invocation chaining, `return value` is more commonly

// used in this case: `var someVal = map.set('a', genVal());`

// Although util.each can be performed on this hashMap directly, user

// should not use the exposed keys, who are prefixed.

// Do not use this method if performance sensitive.

/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */

/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */

/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */

/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */

/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */

/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */

// jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */

/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */

/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */

/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */

/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */

/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */

/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */

/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */

// TODO Draggable for group

// FIXME Draggable on element which has parent rotation or scale

/**
 * Event Mixin
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */

/**
 * Event dispatcher.
 *
 * @alias module:zrender/mixin/Eventful
 * @constructor
 * @param {Object} [eventProcessor] The object eventProcessor is the scope when
 *        `eventProcessor.xxx` called.
 * @param {Function} [eventProcessor.normalizeQuery]
 *        param: {string|Object} Raw query.
 *        return: {string|Object} Normalized query.
 * @param {Function} [eventProcessor.filter] Event will be dispatched only
 *        if it returns `true`.
 *        param: {string} eventType
 *        param: {string|Object} query
 *        return: {boolean}
 * @param {Function} [eventProcessor.afterTrigger] Call after all handlers called.
 *        param: {string} eventType
 */

// FIXME

// Do not publish this feature util it is proved that it makes sense.

/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
     * The handler can only be triggered once, then removed.
     *
     * @param {string} event The event name.
     * @param {string|Object} [query] Condition used on event filter.
     * @param {Function} handler The event handler.
     * @param {Object} context
     */

/**
     * Bind a handler.
     *
     * @param {string} event The event name.
     * @param {string|Object} [query] Condition used on event filter.
     * @param {Function} handler The event handler.
     * @param {Object} [context]
     */

/**
     * Whether any handler has bound.
     *
     * @param  {string}  event
     * @return {boolean}
     */

/**
     * Unbind a event.
     *
     * @param {string} event The event name.
     * @param {Function} [handler] The event handler.
     */

/**
     * Dispatch a event.
     *
     * @param {string} type The event name.
     */

// Optimize advise from backbone

// have more than 2 given arguments

/**
     * Dispatch a event with context, which is specified at the last parameter.
     *
     * @param {string} type The event name.
     */

// `calculate` is optional, default false

// According to the W3C Working Draft, offsetX and offsetY should be relative

// to the padding edge of the target element. The only browser using this convention

// is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does

// not support the properties.

// (see http://www.jacklmoore.com/notes/mouse-position/)

// In zr painter.dom, padding edge equals to border edge.

// When mousemove event triggered on ec tooltip, target is not zr painter.dom, and

// offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y

// is too complex. So css-transfrom dont support in this case temporarily.

// This well-known method below does not support css transform.

// BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect

/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */

// Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;

// See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js

// If e.which has been defined, if may be readonly,

// see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which

// [Caution]: `e.which` from browser is not always reliable. For example,

// when press left button and `mousemove (pointermove)` in Edge, the `e.which`

// is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and

// `mousedown (pointerdown)` is the same as Chrome does.

/**
 * @param {HTMLElement} el
 * @param {string} name
 * @param {Function} handler
 */

// Reproduct the console warning:

// [Violation] Added non-passive event listener to a scroll-blocking <some> event.

// Consider marking event handler as 'passive' to make the page more responsive.

// Just set console log level: verbose in chrome dev tool.

// then the warning log will be printed when addEventListener called.

// See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md

// We have not yet found a neat way to using passive. Because in zrender the dom event

// listener delegate all of the upper events of element. Some of those events need

// to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.

// Before passive can be adopted, these issues should be considered:

// (1) Whether and how a zrender user specifies an event listener passive. And by default,

// passive or not.

// (2) How to tread that some zrender event listener is passive, and some is not. If

// we use other way but not preventDefault of mousewheel and touchmove, browser

// compatibility should be handled.

// var opts = (env.passiveSupported && name === 'mousewheel')

//     ? {passive: true}

//     // By default, the third param of el.addEventListener is `capture: false`.

//     : void 0;

// el.addEventListener(name, handler /* , opts */);

/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */

/**
 * This method only works for mouseup and mousedown. The functionality is restricted
 * for fault tolerance, See the `e.which` compatibility above.
 *
 * @param {MouseEvent} e
 * @return {boolean}
 */

/**
 * To be removed.
 * @deprecated
 */

/**
 * Only implements needed gestures for mobile.
 */

/**
     * @private
     * @type {Array.<Object>}
     */

// Only pinch currently.

/**
     * Proxy of event. can be Dom, WebGLSurface, etc.
     */

/**
     * {target, topTarget, x, y}
     * @private
     * @type {Object}
     */

/**
     * @private
     * @type {Date}
     */

/**
     * @private
     * @type {number}
     */

/**
     * @private
     * @type {module:zrender/core/GestureMgr}
     */

/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */

// If clipped by ancestor.

// FIXME: If clipPath has neither stroke nor fill,

// el.clipPath.contain(x, y) will always return false.

// Attach handler

// If lastHoveredTarget is removed from zr (detected by '__zr') by some API call

// (like 'setOption' or 'dispatchAction') in event handlers, we should find

// lastHovered again here. Otherwise 'mouseout' can not be triggered normally.

// See #6198.

// Mouse out on previous hovered element

// Mouse moving on one element

// Mouse over on a new element

// There might be some doms created by upper layer application

// at the same level of painter.getViewportRoot() (e.g., tooltip

// dom created by echarts), where 'globalout' event should not

// be triggered when mouse enters these doms. (But 'mouseout'

// should be triggered at the original hovered element as usual).

/**
     * Resize
     */

/**
     * Dispatch event
     * @param {string} eventName
     * @param {event=} eventArgs
     */

/**
     * Dispose
     */

/**
     * 设置默认的cursor style
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */

/**
     * 事件分发代理
     *
     * @private
     * @param {Object} targetInfo {target, topTarget} 目标图形元素
     * @param {string} eventName 事件名称
     * @param {Object} event 事件对象
     */

// target can only be an element that is not silent.

// topTarget can be a silent element.

// 冒泡到顶级 zrender 对象

// 分发事件到用户自定义层

// 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

/**
     * @private
     * @param {number} x
     * @param {number} y
     * @param {module:zrender/graphic/Displayable} exclude
     * @return {model:zrender/Element}
     * @method
     */

// Do not do any preventDefault here. Upper application do that if necessary.

// Common handlers

// Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover

// In case click triggered before mouseup

/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */

/**
 * Create a identity matrix.
 * @return {Float32Array|Array.<number>}
 */

/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */

/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */

/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */

// Consider matrix.mul(m, m2, m);

// where out is the same as m2.

// So use temp variable to escape error.

/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */

/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */

/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */

/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */

/**
 * Clone a new matrix.
 * @param {Float32Array|Array.<number>} a
 */

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */

/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */

// If there are no given position, rotation, scale

/**
         * 平移
         * @type {Array.<number>}
         * @default [0, 0]
         */

/**
         * 旋转
         * @type {Array.<number>}
         * @default 0
         */

/**
         * 缩放
         * @type {Array.<number>}
         * @default [1, 1]
         */

/**
     * 旋转和缩放的原点
     * @type {Array.<number>}
     * @default null
     */

/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */

// 应用父节点变换

// 保存这个变换矩阵

/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */

/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */

// Get local transform and decompose them to position, scale, rotation

/**
 * Get global scale
 * @return {Array.<number>}
 */

/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */

/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */

/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */

// Translate to origin

// Translate back from origin

/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */

/**
    * @param {number} k
    * @return {number}
    */

// 三次方的缓动（t^3）

// 四次方的缓动（t^4）

// 五次方的缓动（t^5）

// 正弦曲线的缓动（sin(t)）

// 指数曲线的缓动（2^t）

// 圆形曲线的缓动（sqrt(1-t^2)）

// 创建类似于弹簧在停止前来回振荡的动画

// 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

// 创建弹跳效果

/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */

// 生命周期

// 延时

// 开始时间

// this._startTime = new Date().getTime() + this._delay;// 单位毫秒

// 是否循环

// Set startTime on first step, or _startTime may has milleseconds different between clips

// PENDING

// 还没开始

// 结束

// 动画完成将这个控制器标识为待删除

// 在Animation.update中进行批量删除

/**
     * @type {module:zrender/core/LRU~Entry}
     */

// Simple LRU cache use doubly linked list

// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */

/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */

/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */

/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */

// Is head

// Is tail

/**
 * @return {number}
 */

/**
 * Clear list
 */

/**
 * @constructor
 * @param {} val
 */

/**
     * @type {}
     */

/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */

/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */

// Reuse last removed entry

// Remove the least recently used

/**
 * @param  {string} key
 * @return {}
 */

// Put the latest used entry in the tail

/**
 * Clear the cache
 */

// Seems to be what Chrome does (vs truncation).

// Clamp to integer 0 .. 255.

// Clamp to float 0.0 .. 1.0.

// int or percentage.

// float or percentage.

// Reuse removed array

/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */

// colorStr may be not string

// Remove all whitespace, not compliant, but should just be more accepting.

// Color keywords (and transparent) lookup.

// #abc and #abc123 syntax.

// TODO(deanm): Stricter parsing.

// To allow case fallthrough.

// Fall through.

/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */

// 0 .. 1

// NOTE(deanm): According to the CSS spec s/l should only be

// percentages, but we don't bother and let float or percentage.

/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */

/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */

/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */

/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */

/**
 * @deprecated
 */

/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */

/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */

// RGB from 0 to 255

// HSL results from 0 to 1

// Clamp to integer 0 .. 360.

/**
 * @module echarts/animation/Animator
 */

/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */

/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */

/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */

// arr0 is source array, arr1 is target array.

// Do some preprocess to avoid error happened when interpolating from arr0 to arr1

// Cut the previous

// Fill the previous

// Handling NaN value

/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */

/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */

/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */

// Guess data type

// Sort keyframe as ascending

// Percents of each keyframe

// Value of each keyframe

// Assume value is a color when it is a string

// Check if value is equal, deep check if value is array

// Try converting a string to a color array

// Polyfill array and NaN value

// Cache the key of last frame to speed up when

// animation playback is sequency

// Find the range keyframes

// kf1-----kf2---------current--------kf3

// find kf2 and kf3 and do interpolation

// In the easing function like elasticOut, percent may less than 0

// PENDING really need to do this ?

// String is step(0.5)

/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */

/**
     * 设置动画关键帧
     * @param  {number} time 关键帧时间，单位是ms
     * @param  {Object} props 关键帧的属性值，key-value表示
     * @return {module:zrender/animation/Animator}
     */

/* ms */

// Invalid value

// zrLog('Invalid property ' + propName);

// If time is 0

//  Then props is given initialize value

// Else

//  Initialize value from current prop value

/**
     * 添加动画每一帧的回调函数
     * @param  {Function} callback
     * @return {module:zrender/animation/Animator}
     */

// Clear all tracks

// Clear all clips

/**
     * 开始执行动画
     * @param  {string|Function} [easing]
     *         动画缓动函数，详见{@link module:zrender/animation/easing}
     * @param  {boolean} forceAnimate
     * @return {module:zrender/animation/Animator}
     */

// If start after added to animation

// Add during callback on the last clip

// This optimization will help the case that in the upper application

// the view may be refreshed frequently, where animation will be

// called repeatly but nothing changed.

/**
     * 停止动画
     * @param {boolean} forwardToLast If move to last frame before stop
     */

// Move to last frame before stop

/**
     * 设置动画延迟开始的时间
     * @param  {number} time 单位ms
     * @return {module:zrender/animation/Animator}
     */

/**
     * 添加动画结束的回调
     * @param  {Function} cb
     * @return {module:zrender/animation/Animator}
     */

/**
     * @return {Array.<module:zrender/animation/Clip>}
     */

// If in browser environment

/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */

// retina 屏幕优化

/**
     * @type {Array.<module:zrender/animation/Animator>}
     * @readOnly
     */

/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */

// animateTo(target, time, easing, callback);

// Stop all previous animations

/**
 * @param {string} path=''
 * @param {Object} source=animatable
 * @param {Object} target
 * @param {number} [time=500]
 * @param {number} [delay=0]
 * @param {boolean} [reverse] If `true`, animate
 *        from the `target` to current state.
 *
 * @example
 *  // Animate position
 *  el._animateToShallow({
 *      position: [10, 10]
 *  })
 *
 *  // Animate shape, style and position in 100ms, delayed 100ms
 *  el._animateToShallow({
 *      shape: {
 *          width: 500
 *      },
 *      style: {
 *          fill: 'red'
 *      }
 *      position: [10, 10]
 *  }, 100, 100)
 */

// Animators may be removed immediately after start

// if there is nothing to animate

// No animators. This should be checked before animators[i].start(),

// because 'done' may be executed immediately if no need to animate.

// Start after all animators created

// Incase any animator is done immediately when all animation properties are not changed

// Attr directly if not has property

// FIXME, if some property not needed for element ?

// Only support set shape or style

/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */

/**
     * 动画
     *
     * @param {string} path The path to fetch value from object, like 'a.b.c'.
     * @param {boolean} [loop] Whether to loop animation.
     * @return {module:zrender/animation/Animator}
     * @example:
     *     el.animate('style', false)
     *         .when(1000, {x: 10} )
     *         .done(function(){ // Animation done })
     *         .start()
     */

// If animating shape

// FIXME Animator will not be removed if use `Animator#stop` to stop animation

// If animate after added to the zrender

/**
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     * @param {Object} target
     * @param {number} [time=500] Time in ms
     * @param {string} [easing='linear']
     * @param {number} [delay=0]
     * @param {Function} [callback]
     * @param {Function} [forceAnimate] Prevent stop animation and callback
     *        immediently when target values are the same as current values.
     *
     * @example
     *  // Animate position
     *  el.animateTo({
     *      position: [10, 10]
     *  }, function () { // done })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
     *  el.animateTo({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100, 'cubicOut', function () { // done })
     */

// TODO Return animation key

/**
     * Animate from the target state to current state.
     * The params and the return value are the same as `this.animateTo`.
     */

/**
     * 画布元素ID
     * @type {string}
     */

/**
     * 元素类型
     * Element type
     * @type {string}
     */

/**
     * 元素名字
     * Element name
     * @type {string}
     */

/**
     * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
     * ZRender instance will be assigned when element is associated with zrender
     * @name module:/zrender/Element#__zr
     * @type {module:zrender/ZRender}
     */

/**
     * 图形是否忽略，为true时忽略图形的绘制以及事件触发
     * If ignore drawing and events of the element object
     * @name module:/zrender/Element#ignore
     * @type {boolean}
     * @default false
     */

/**
     * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
     * 该路径会继承被裁减对象的变换
     * @type {module:zrender/graphic/Path}
     * @see http://www.w3.org/TR/2dcontext/#clipping-region
     * @readOnly
     */

/**
     * 是否是 Group
     * @type {boolean}
     */

/**
     * Drift element
     * @param  {number} dx dx on the global space
     * @param  {number} dy dy on the global space
     */

/**
     * Hook before update
     */

/**
     * Hook after update
     */

/**
     * Update each frame
     */

/**
     * @param  {Function} cb
     * @param  {}   context
     */

/**
     * @protected
     */

// Copy the array

/**
     * Hide the element
     */

/**
     * Show the element
     */

/**
     * @param {string|Object} key
     * @param {*} value
     */

/**
     * @param {module:zrender/graphic/Path} clipPath
     */

// Remove previous clip path

/**
     */

/**
     * Add self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */

// 添加动画

/**
     * Remove self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */

// 移除动画

/**
 * @module echarts/core/BoundingRect
 */

/**
 * @alias module:echarts/core/BoundingRect
 */

/**
     * @type {number}
     */

/**
     * @param {module:echarts/core/BoundingRect} other
     */

/**
     * @param {Array.<number>} m
     * @methods
     */

// In case usage like this

// el.getBoundingRect().applyTransform(el.transform)

// And element has no transform

/**
     * Calculate matrix of transforming from self to target rect
     * @param  {module:zrender/core/BoundingRect} b
     * @return {Array.<number>}
     */

// 矩阵右乘

/**
     * @param {(module:echarts/core/BoundingRect|Object)} b
     * @return {boolean}
     */

// Normalize negative width/height.

/**
     * @return {module:echarts/core/BoundingRect}
     */

/**
     * Copy from another rect
     */

/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */

/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */

/**
     * @type {string}
     */

/**
     * 所有子孙元素是否响应鼠标事件
     * @name module:/zrender/container/Group#silent
     * @type {boolean}
     * @default false
     */

/**
     * @return {Array.<module:zrender/Element>}
     */

/**
     * 获取指定 index 的儿子节点
     * @param  {number} idx
     * @return {module:zrender/Element}
     */

/**
     * 获取指定名字的儿子节点
     * @param  {string} name
     * @return {module:zrender/Element}
     */

/**
     * @return {number}
     */

/**
     * 添加子节点到最后
     * @param {module:zrender/Element} child
     */

/**
     * 添加子节点在 nextSibling 之前
     * @param {module:zrender/Element} child
     * @param {module:zrender/Element} nextSibling
     */

/**
     * 移除子节点
     * @param {module:zrender/Element} child
     */

/**
     * 移除所有子节点
     */

/**
     * 遍历所有子节点
     * @param  {Function} cb
     * @param  {}   context
     */

/**
     * 深度优先遍历所有子孙节点
     * @param  {Function} cb
     * @param  {}   context
     */

/**
     * @return {module:zrender/core/BoundingRect}
     */

// TODO Caching

// TODO

// The boundingRect cacluated by transforming original

// rect may be bigger than the actual bundingRect when rotation

// is used. (Consider a circle rotated aginst its center, where

// the actual boundingRect should be the same as that not be

// rotated.) But we can not find better approach to calculate

// actual boundingRect yet, considering performance.

// https://github.com/mziccard/node-timsort

// throw new Error('mergeLow preconditions were not respected');

// throw new Error('mergeHigh preconditions were not respected');

// Use timsort because in most case elements are partially sorted

// https://jsfiddle.net/pissang/jr4x7mdm/8/

/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */

/**
     * @param  {Function} cb
     *
     */

/**
     * 返回所有图形的绘制队列
     * @param {boolean} [update=false] 是否在返回前更新该数组
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
     *
     * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
     * @return {Array.<module:zrender/graphic/Displayable>}
     */

/**
     * 更新图形的绘制队列。
     * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
     * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
     */

// FIXME 效率影响

// Recursively add clip path

// clipPath 的变换是基于使用这个 clipPath 的元素

// Force to mark as dirty if group is dirty

// FIXME __dirtyPath ?

// Mark group clean here

/**
     * 添加图形(Shape)或者组(Group)到根节点
     * @param {module:zrender/Element} el
     */

/**
     * 删除指定的图形(Shape)或者组(Group)
     * @param {string|Array.<string>} [el] 如果为空清空整个Storage
     */

// 不指定el清空

/**
     * 清空并且释放Storage
     */

// Fix NaN when rect is Infinity

/**
     * @type {Array.<number>}
     */

/**
     * If stroke ignore scale
     * @type {Boolean}
     */

// Bounding rect text configuration

// Not affected by element transform

/**
     * If `fontSize` or `fontFamily` exists, `font` will be reset by
     * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
     * So do not visit it directly in upper application (like echarts),
     * but use `contain/text#makeFont` instead.
     * @type {string}
     */

/**
     * The same as font. Use font please.
     * @deprecated
     * @type {string}
     */

/**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */

/**
     * It helps merging respectively, rather than parsing an entire font string.
     * Should be 12 but not '12px'.
     * @type {number}
     */

/**
     * Reserved for special functinality, like 'hr'.
     * @type {string}
     */

/**
     * Only for textBackground.
     * @type {number}
     */

/**
     * textStroke may be set as some color as a default
     * value in upper applicaion, where the default value
     * of textStrokeWidth should be 0 to make sure that
     * user can choose to do not use text stroke.
     * @type {number}
     */

/**
     * 'inside', 'left', 'right', 'top', 'bottom'
     * [x, y]
     * Based on x, y of rect.
     * @type {string|Array.<number>}
     * @default 'inside'
     */

/**
     * If not specified, use the boundingRect of a `displayable`.
     * @type {Object}
     */

/**
     * [x, y]
     * @type {Array.<number>}
     */

/**
     * Whether transform text.
     * Only useful in Path and Image element
     * @type {boolean}
     */

/**
     * Text rotate around position of Path or Image
     * Only useful in Path and Image element and transformText is false.
     */

/**
     * Text origin of text rotation, like [10, 40].
     * Based on x, y of rect.
     * Useful in label rotation of circular symbol.
     * By default, this origin is textPosition.
     * Can be 'center'.
     * @type {string|Array.<number>}
     */

/**
     * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
     * @type {number|Array.<number>}
     */

/**
     * Text styles for rich text.
     * @type {Object}
     */

/**
     * {outerWidth, outerHeight, ellipsis, placeholder}
     * @type {Object}
     */

/**
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @type {string}
     */

/**
     * @param {CanvasRenderingContext2D} ctx
     */

// FIXME Invalid property value will cause style leak from previous element.

/**
     * Extend from other style
     * @param {zrender/graphic/Style} otherStyle
     * @param {boolean} overwrite true: overwrirte any way.
     *                            false: overwrite only when !target.hasOwnProperty
     *                            others: overwrite when property is not null/undefined.
     */

/**
     * Batch setting style with a given object
     * @param {Object|string} obj
     * @param {*} [obj]
     */

/**
     * Clone
     * @return {zrender/graphic/Style} [description]
     */

// Provide for others

// Should do nothing more in this constructor. Because gradient can be

// declard by `color: {image: ...}`, where this constructor will not be called.

// Can be cloned

/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */

/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */

// In node or some other non-browser environment

/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */

// Not in node

// 避免页面选中的尴尬

// Configs

/**
     * 每次清空画布的颜色
     * @type {string}
     * @default 0
     */

/**
     * 是否开启动态模糊
     * @type {boolean}
     * @default false
     */

/**
     * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     * @type {number}
     * @default 0.7
     */

/**
     * Layer dpr
     * @type {number}
     */

/**
     * @param  {number} width
     * @param  {number} height
     */

/**
     * 清空该层画布
     * @param {boolean} [clearAll]=false Clear all with out motion blur
     * @param {Color} [clearColor]
     */

// Gradient

// Cache canvas gradient

// https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809

/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

// Image should not be loaded repeatly.

// Only when there is no existent image or existent image src

// is different, this method is responsible for load.

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */

// textContain.measureText may be overrided in SVG or VML

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */

/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */

// FIXME Right to left language

/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */

/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */

/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */

// It is not appropriate that every line has '...' when truncate multiple lines.

// Other languages?

// Consider proportional font?

// Reserve some gap.

// Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.

// Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

/**
 * @public
 * @param {string} font
 * @return {number} line height
 */

// FIXME A rough approach.

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */

/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */

// Calculate layout info of tokens.

// textHeight should not be inherited, consider it can be specified

// as box height of the block.

// Percent width, can be `100%`, can be used in drawing separate

// line when box width is needed to be auto.

// FIXME: If image is not loaded and textWidth is not specified, calling

// `getBoundingRect()` will not get correct result.

// Use cases:

// (1) If image is not loaded, it will be loaded at render phase and call

// `dirty()` and `textBackgroundColor.image` will be replaced with the loaded

// image, and then the right size will be calculated here at the next tick.

// See `graphic/helper/text.js`.

// (2) If image loaded, and `textBackgroundColor.image` is image src string,

// use `imageHelper.findExistImage` to find cached image.

// `imageHelper.findExistImage` will always be called here before

// `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`

// which ensures that image will not be rendered before correct size calcualted.

// Should not base on outerWidth, because token can not be placed out of padding.

// The first token should be appended to the last line.

// If there is '', insert it as a placeholder.

// Consider cases:

// (1) ''.split('\n') => ['', '\n', ''], the '' at the first item

// (which is a placeholder) should be replaced by new token.

// (2) A image backage, where token likes {a|}.

// (3) A redundant '' will affect textAlign in line.

// (4) tokens with the same tplName should not be merged, because

// they should be displayed in different box (with border and padding).

// Consider text is '', only insert when it is the "lineHolder" or

// "emptyStr". Otherwise a redundant '' will affect textAlign in line.

// Other tokens always start a new line.

// FIXME in node-canvas fontWeight is before fontStyle

// Use `fontSize` `fontFamily` to check whether font properties are defined.

// If font properties are defined, `fontFamily` should not be ignored.

/**
 * @param {Object} ctx
 * @param {Object} shape
 * @param {number} shape.x
 * @param {number} shape.y
 * @param {number} shape.width
 * @param {number} shape.height
 * @param {number} shape.r
 */

// Convert width and height to positive for better borderRadius

// Avoid assign to an exported variable, for transforming to cjs.

// TODO: Have not support 'start', 'end' yet.

/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */

// Compatible with textBaseline.

/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.
 */

// Do not do cache for rich text because of the complexity.

// But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.

// Origin of textRotation should be the base point of text drawing.

// The other tokens are placed as textAlign 'center' if there is enough space.

// Consider width specified by user, use 'center' rather than 'left'.

// Avoid setting to ctx according to prevEl if possible for

// performance in scenarios of large amount text.

// Only take and check cache for `Text` el, but not RectText.

// Prevent from using cache in `Style::bind`, because of the case:

// ctx property is modified by other properties than `Style::bind`

// used, and Style::bind is called next.

// Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically

// we can make font cache on ctx, which can cache for text el that are discontinuous.

// But layer save/restore needed to be considered.

// if (styleFont !== ctx.__fontCache) {

//     ctx.font = styleFont;

//     if (prevEl !== WILL_BE_RESTORED) {

//         ctx.__fontCache = styleFont;

// Use the final font from context-2d, because the final

// font might not be the style.font when it is illegal.

// But get `ctx.font` might be time consuming.

// Consider performance, do not call getTextWidth util necessary.

// Always set textAlign and textBase line, because it is difficute to calculate

// textAlign from prevEl, and we dont sure whether textAlign will be reset if

// font set happened.

// Force baseline to be "middle". Otherwise, if using "top", the

// text will offset downward a little bit in font "Microsoft YaHei".

// Set text opacity

// Always set shadowBlur and shadowOffset to avoid leak from displayable.

// `textBaseline` is set as 'middle'.

// Optimize simply, in most cases only one line exists.

// Fill after stroke so the outline will not cover the main part.

// textRotation only apply in RectText.

// Positive: anticlockwise

// 'ctx.textBaseline' is always set as 'middle', for sake of

// the bias of "Microsoft YaHei".

// style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}

// shape: {x, y, width, height}

// Replace image, so that `contain/text.js#parseRichText`

// will get correct result in next tick.

// Text position represented by coord

// Percent

// Default align and baseline when has textPosition

// textOffset is only support in RectText, otherwise

// we have to adjust boundingRect for textOffset.

/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */

/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */

/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */

/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */

/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */

// Extend properties

/**
     * @type {module:zrender/graphic/Style}
     */

// Shapes for cascade clipping.

/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

/**
     * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
     * Dirty flag. From which painter will determine if this displayable object needs brush
     * @name module:zrender/graphic/Displayable#__dirty
     * @type {boolean}
     */

/**
     * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
     * If ignore drawing of the displayable object. Mouse event will still be triggered
     * @name module:/zrender/graphic/Displayable#invisible
     * @type {boolean}
     * @default false
     */

/**
     * Draw text in a rect with specified position.
     * @param  {CanvasRenderingContext2D} ctx
     * @param  {Object} rect Displayable rect
     */

// Optimize, avoid normalize every time.

// Convert to string

// Do not provide prevEl to `textHelper.renderText` for ctx prop cache,

// but use `ctx.save()` and `ctx.restore()`. Because the cache for rect

// text propably break the cache for its host elements.

// Transform rect to view space

// transformText and textRotation can not be used at the same time.

/**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */

/**
     * z层level，决定绘画在哪层canvas中
     * @name module:/zrender/graphic/Displayable#zlevel
     * @type {number}
     * @default 0
     */

/**
     * 是否可拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */

/**
     * 是否正在拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */

/**
     * 是否相应鼠标事件
     * @name module:/zrender/graphic/Displayable#silent
     * @type {boolean}
     * @default false
     */

/**
     * If enable culling
     * @type {boolean}
     * @default false
     */

/**
     * Mouse cursor when hovered
     * @name module:/zrender/graphic/Displayable#cursor
     * @type {string}
     */

/**
     * If hover area is bounding rect
     * @name module:/zrender/graphic/Displayable#rectHover
     * @type {string}
     */

/**
     * Render the element progressively when the value >= 0,
     * usefull for large data.
     * @type {boolean}
     */

/**
     * @type {boolean}
     */

/**
     * Scale ratio for global scale.
     * @type {boolean}
     */

/**
     * 图形绘制方法
     * @param {CanvasRenderingContext2D} ctx
     */

// Interface

/**
     * 获取最小包围盒
     * @return {module:zrender/core/BoundingRect}
     */

/**
     * 判断坐标 x, y 是否在图形上
     * If displayable element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */

/**
     * 判断坐标 x, y 是否在图形的包围盒上
     * If bounding rect of element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */

/**
     * 标记图形元素为脏，并且在下一帧重绘
     * Mark displayable element dirty and refresh next frame
     */

/**
     * 图形是否会触发事件
     * If displayable object binded any event
     * @return {boolean}
     */

// TODO, 通过 bind 绑定的事件

// isSilent: function () {

//     return !(

//         this.hoverable || this.draggable

//         || this.onmousemove || this.onmouseover || this.onmouseout

//         || this.onmousedown || this.onmouseup || this.onclick

//         || this.ondragenter || this.ondragover || this.ondragleave

//         || this.ondrop

//     );

// },

/**
     * Alias for animate('style')
     * @param {boolean} loop
     */

/**
     * @param {Object|string} key
     * @param {*} value
     */

/**
     * Use given style object
     * @param  {Object} obj
     */

// Must bind each time

// 图片已经加载完成

// if (image.nodeName.toUpperCase() == 'IMG') {

//     if (!image.complete) {

//         return;

// Else is canvas

// Keep image/height ratio

// 设置transform

// Draw rect text

// Only restore transform when needs draw text.

// In node environment using node-canvas

/**
     * @type {boolean}
     * @private
     */

/**
     * 绘图容器
     * @type {HTMLElement}
     */

/**
     * @type {module:zrender/Storage}
     */

/**
     * @type {Array.<number>}
     * @private
     */

/**
     * @type {Object.<string, module:zrender/Layer>}
     * @private
     */

/**
     * @type {Object.<string, Object>}
     * @private
     */

/**
     * zrender will do compositing when root is a canvas and have multiple zlevels.
     */

// Use canvas width and height directly

// Create layer if only one given canvas

// Device can be specified to create a high dpi image.

// FIXME Use canvas width and height

// mainLayer.resize(width, height);

// Not use common zlevel.

/**
     * @type {module:zrender/Layer}
     * @private
     */

// domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬

/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */

/**
     * If painter use a single canvas
     * @return {boolean}
     */

/**
     * @return {HTMLDivElement}
     */

/**
     * 刷新
     * @param {boolean} [paintAll=false] 强制绘制所有displayable
     */

// Paint custum layers

// Use a extream large zlevel

// FIXME?

// Original el is removed

// Use transform

// FIXME style and shape ?

// el.

// PENDING, If only builtin layer?

// All elements in this layer are cleared.

// Give 15 millisecond to draw.

// The rest elements will be drawn in the next frame.

// Needs restore the state. If last drawn element is in the clipping area.

// Flush for weixin application

// Ignore invisible element

// Optimize when clipping on group with several elements

// Can both be null or undefined

// If has previous clipping state, restore from it

// Reset prevEl since context has been restored

// New clipping state

// Transform back

/**
     * 获取 zlevel 所在层，如果不存在则会创建一个新的层
     * @param {number} zlevel
     * @param {boolean} virtual Virtual layer will not be inserted into dom.
     * @return {module:zrender/Layer}
     */

// Create a new layer

// Context is created after dom inserted to document

// Or excanvas will get 0px clientWidth and clientHeight

// Check if is a valid layer

// Vitual layer will not directly show on the screen.

// (It can be a WebGL layer and assigned to a ZImage element)

// But it still under management of zrender.

// Iterate each layer

// Iterate each buildin layer

// Iterate each other layer except buildin layer

/**
     * 获取所有已创建的层
     * @param {Array.<module:zrender/Layer>} [prevLayer]
     */

// PENDING If change one incremental element style ?

// TODO Where there are non-incremental elements between incremental elements.

// Mark layer draw index needs to update.

// Start draw from the first dirty element.

// Used in last frame but not in this frame. Needs clear

// For incremental layer. In case start index changed and no elements are dirty.

/**
     * 清除hover层外所有内容
     */

/**
     * 修改指定zlevel的绘制参数
     *
     * @param {string} zlevel
     * @param {Object} config 配置对象
     * @param {string} [config.clearColor=0] 每次清空画布的颜色
     * @param {string} [config.motionBlur=false] 是否开启动态模糊
     * @param {number} [config.lastFrameAlpha=0.7]
     *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     */

/**
     * 删除指定层
     * @param {number} zlevel 层所在的zlevel
     */

/**
     * 区域大小变化后重绘
     */

// FIXME Why ?

// Save input w/h

// 优化没有实际改变的resize

// Maybe in node or worker

/**
     * 清除单独的一个层
     * @param {number} zlevel
     */

/**
     * 释放
     */

/**
     * Get canvas which has all thing rendered
     * @param {Object} opts
     * @param {string} [opts.backgroundColor]
     * @param {number} [opts.pixelRatio]
     */

// PENDING, echarts-gl and incremental rendering.

/**
     * 获取绘图区域宽度
     */

/**
     * 获取绘图区域高度
     */

// IE8 does not support getComputedStyle, but it use VML.

// private properties

/**
     * 添加 clip
     * @param {module:zrender/animation/Clip} clip
     */

/**
     * 添加 animator
     * @param {module:zrender/animation/Animator} animator
     */

/**
     * 删除动画片段
     * @param {module:zrender/animation/Clip} clip
     */

/**
     * 删除动画片段
     * @param {module:zrender/animation/Animator} animator
     */

// Throw out the events need to be called after

// stage.update, like destroy

// Remove the finished clip

// 'frame' should be triggered before stage, because upper application

// depends on the sequence (e.g., echarts-stream and finish

// event judge)

/**
     * Start animation.
     */

/**
     * Stop animation.
     */

/**
     * Pause animation.
     */

/**
     * Resume animation.
     */

/**
     * Clear animation.
     */

/**
     * Whether animation finished.
     */

/**
     * Creat animator for a target, whose props can be animated.
     *
     * @param  {Object} target
     * @param  {Object} options
     * @param  {boolean} [options.loop=false] Whether loop animation.
     * @param  {Function} [options.getter=null] Get value from target.
     * @param  {Function} [options.setter=null] Set value to target.
     * @return {module:zrender/animation/Animation~Animator}
     */

// TODO Gap

// function onMSGestureChange(proxy, event) {

//     if (event.translationX || event.translationY) {

//         // mousemove is carried by MSGesture to reduce the sensitivity.

//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);

//     if (event.scale !== 1) {

//         event.pinchX = event.offsetX;

//         event.pinchY = event.offsetY;

//         event.pinchScale = event.scale;

//         proxy.handler.dispatchToElement(event.target, 'pinch', event);

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */

/**
     * Mouse move handler
     * @inner
     * @param {Event} event
     */

/**
     * Mouse out handler
     * @inner
     * @param {Event} event
     */

// 忽略包含在root中的dom引起的mouseOut

/**
     * Touch开始响应函数
     * @inner
     * @param {Event} event
     */

// Default mouse behaviour should not be disabled here.

// For example, page may needs to be slided.

// Mark touch, which is useful in distinguish touch and

// mouse event in upper applicatoin.

// In touch device, trigger `mousemove`(`mouseover`) should

// be triggered, and must before `mousedown` triggered.

/**
     * Touch移动响应函数
     * @inner
     * @param {Event} event
     */

// Mouse move should always be triggered no matter whether

// there is gestrue event, because mouse move and pinch may

// be used at the same time.

/**
     * Touch结束响应函数
     * @inner
     * @param {Event} event
     */

// Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is

// triggered in `touchstart`. This seems to be illogical, but by this mechanism,

// we can conveniently implement "hover style" in both PC and touch device just

// by listening to `mouseover` to add "hover style" and listening to `mouseout`

// to remove "hover style" on an element, without any additional code for

// compatibility. (`mouseout` will not be triggered in `touchend`, so "hover

// style" will remain for user view)

// click event should always be triggered no matter whether

// there is gestrue event. System click can not be prevented.

// if (useMSGuesture(this, event)) {

//     this._msGesture.addPointer(event.pointerId);

// pointermove is so sensitive that it always triggered when

// tap(click) on touch screen, which affect some judgement in

// upper application. So, we dont support mousemove on MS touch

// device yet.

// pointerout will be triggered when tap on touch screen

// (IE11+/Edge on MS Surface) after click event triggered,

// which is inconsistent with the mousout behavior we defined

// in touchend. So we unify them.

// (check domHandlers.touchend for detailed explanation)

// function useMSGuesture(handlerProxy, event) {

//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;

/**
     * @private
     * @type {boolean}
     */

/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */

// Only IE11+/Edge

// 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),

// IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event

// at the same time.

// 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on

// screen, which do not occurs in pointer event.

// So we use pointer event to both detect touch gesture and mouse behavior.

// 1. Considering some devices that both enable touch and mouse event (like on MS Surface

// and lenovo X240, @see #2350), we make mouse event be always listened, otherwise

// mouse event can not be handle in those devices.

// 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent

// mouseevent after touch event triggered, see `setTouchTimer`.

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/

/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} [opts]
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */

/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */

/**
 * @module zrender/ZRender
 */

/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */

/**
     * @type {HTMLDomElement}
     */

// TODO WebGL

/**
     * @type {module:zrender/animation/Animation}
     */

// 修改 storage.delFromStorage, 每次删除元素之前删除动画

// FIXME 有点ugly

/**
     * 获取实例唯一标识
     * @return {string}
     */

/**
     * 添加元素
     * @param  {module:zrender/Element} el
     */

/**
     * 删除元素
     * @param  {module:zrender/Element} el
     */

/**
     * Change configuration of layer
     * @param {string} zLevel
     * @param {Object} config
     * @param {string} [config.clearColor=0] Clear color
     * @param {string} [config.motionBlur=false] If enable motion blur
     * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
    */

/**
     * Set background color
     * @param {string} backgroundColor
     */

/**
     * Repaint the canvas immediately
     */

// var start = new Date();

// Clear needsRefresh ahead to avoid something wrong happens in refresh

// Or it will cause zrender refreshes again and again.

/**
         * Avoid trigger zr.refresh in Element#beforeUpdate hook
         */

/**
     * Mark and repaint the canvas in the next frame of browser
     */

/**
     * Perform all refresh
     */

/**
     * Add element to hover layer
     * @param  {module:zrender/Element} el
     * @param {Object} style
     */

/**
     * Add element from hover layer
     * @param  {module:zrender/Element} el
     */

/**
     * Clear all hover elements in hover layer
     * @param  {module:zrender/Element} el
     */

/**
     * Refresh hover in next frame
     */

/**
     * Refresh hover immediately
     */

/**
     * Resize the canvas.
     * Should be invoked when container size is changed
     * @param {Object} [opts]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     */

/**
     * Stop and clear all animation immediately
     */

/**
     * Get container width
     */

/**
     * Get container height
     */

/**
     * Export the canvas as Base64 URL
     * @param {string} type
     * @param {string} [backgroundColor='#fff']
     * @return {string} Base64 URL
     */

// toDataURL: function(type, backgroundColor) {

//     return this.painter.getRenderedCanvas({

//         backgroundColor: backgroundColor

//     }).toDataURL(type);

/**
     * Converting a path to image.
     * It has much better performance of drawing image rather than drawing a vector path.
     * @param {module:zrender/graphic/Path} e
     * @param {number} width
     * @param {number} height
     */

/**
     * Set default cursor
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */

/**
     * Find hovered element
     * @param {number} x
     * @param {number} y
     * @return {Object} {target, topTarget}
     */

/**
     * Bind event
     *
     * @param {string} eventName Event name
     * @param {Function} eventHandler Handler function
     * @param {Object} [context] Context object
     */

/**
     * Unbind event
     * @param {string} eventName Event name
     * @param {Function} [eventHandler] Handler function
     */

/**
     * Trigger event manually
     *
     * @param {string} eventName Event name
     * @param {event=} event Event object
     */

/**
     * Clear all objects and the canvas.
     */

/**
     * Dispose self.
     */

/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */

/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */

/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *          show: false,
 *          position: 'outside',
 *          fontSize: 18
 *     },
 *     emphasis: {
 *          label: { show: true }
 *     }
 * @param {Object} opt
 * @param {string} key
 * @param {Array.<string>} subOpts
 */

// Caution: performance sensitive.

// Default emphasis option from normal

// modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([

//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',

//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',

//     // FIXME: deprecated, check and remove it.

//     'textStyle'

// ]);

/**
 * The method do not ensure performance.
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 * @param {string|number|Date|Array|Object} dataItem
 * @return {number|string|Date|Array.<number|string|Date>}
 */

/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 * @param {string|number|Date|Array|Object} dataItem
 */

/**
 * Mapping to exists for merge.
 *
 * @public
 * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
 * @param {Object|Array.<Object>} newCptOptions
 * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          index of which is the same as exists.
 */

// Mapping by the order by original option (but not order of

// new option) in merge mode. Because we should ensure

// some specified index (like xAxisIndex) is consistent with

// original option, which is easy to understand, espatially in

// media query. And in most case, merge option is used to

// update partial option but not be expected to change order.

// Mapping by id or name if specified.

// id has highest priority.

// Otherwise mapping by index.

/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 *
 * @public
 * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          which order is the same as exists.
 * @return {Array.<Object>} The input.
 */

// We use this id to hash component models and view instances

// in echarts. id can be specified by user, or auto generated.

// The id generation rule ensures new view instance are able

// to mapped to old instance when setOption are called in

// no-merge mode. So we generate model id by name and plus

// type in view id.

// name can be duplicated among components, which is convenient

// to specify multi components (like series) by one name.

// Ensure that each id is distinct.

// Make name and id.

// name can be overwitten. Consider case: axis.name = '20km'.

// But id generated by name will not be changed, which affect

// only in that case: setOption with 'not merge mode' and view

// instance will be recreated, which can be accepted.

// Consider this situatoin:

//  optionA: [{name: 'a'}, {name: 'a'}, {..}]

//  optionB [{..}, {name: 'a'}, {name: 'a'}]

// Series with the same name between optionA and optionB

// should be mapped.

// Is specified when `indexOf` get -1 or > 0.

/**
 * @public
 * @param {Object} cptOption
 * @return {boolean}
 */

/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
 */

/**
 * @param {module:echarts/data/List} data
 * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
 */

/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * var inner = zrUitl.makeInner();
 *
 * function some1(hostObj) {
 *      inner(hostObj).someProperty = 1212;
 *      ...
 * }
 * function some2() {
 *      var fields = inner(this);
 *      fields.someProperty1 = 1212;
 *      fields.someProperty2 = 'xx';
 *      ...
 * }
 *
 * @return {Function}
 */

// Consider different scope by es module import.

/**
 * @param {module:echarts/model/Global} ecModel
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex, seriesId, seriesName,
 *            geoIndex, geoId, geoName,
 *            bmapIndex, bmapId, bmapName,
 *            xAxisIndex, xAxisId, xAxisName,
 *            yAxisIndex, yAxisId, yAxisName,
 *            gridIndex, gridId, gridName,
 *            ... (can be extended)
 *        }
 *        Each properties can be number|string|Array.<number>|Array.<string>
 *        For example, a finder could be
 *        {
 *            seriesIndex: 3,
 *            geoId: ['aa', 'cc'],
 *            gridName: ['xx', 'rr']
 *        }
 *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
 *        If nothing or null/undefined specified, return nothing.
 * @param {Object} [opt]
 * @param {string} [opt.defaultMainType]
 * @param {Array.<string>} [opt.includeMainTypes]
 * @return {Object} result like:
 *        {
 *            seriesModels: [seriesModel1, seriesModel2],
 *            seriesModel: seriesModel1, // The first model
 *            geoModels: [geoModel1, geoModel2],
 *            geoModel: geoModel1, // The first model
 *            ...
 *        }
 */

// Exclude 'dataIndex' and other illgal keys.

/**
 * Group a list by key.
 *
 * @param {Array} array
 * @param {Function} getKey
 *        param {*} Array item
 *        return {string} key
 * @return {Object} Result
 *        {Array}: keys,
 *        {module:zrender/core/util/HashMap} buckets: {key -> Array}
 */

/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */

/**
 * @public
 */

/**
 * Can not use instanceof, consider different scope by
 * cross domain or es module import in ec extensions.
 * Mount a method "isInstance()" to Clz.
 */

// superCall should have class info, which can not be fetch from 'this'.

// Consider this case:

// class A has method f,

// class B inherits class A, overrides method f, f call superApply('f'),

// class C inherits class B, do not overrides method f,

// then when method of class C is called, dead loop occured.

/**
 * @param {Object} entity
 * @param {Object} options
 * @param {boolean} [options.registerWhenExtend]
 * @public
 */

/**
     * Component model classes
     * key: componentType,
     * value:
     *     componentClass, when componentType is 'xxx'
     *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
     * @type {Object}
     */

// Just consider componentType.main.

/**
     * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
     */

/**
     * If a main type is container and has sub types
     * @param  {string}  mainType
     * @return {boolean}
     */

/**
 * @param {string|Array.<string>} properties
 */

// TODO Parse shadow style

// TODO Only shallow path support

// Normalize

/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */

/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */

/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */

/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */

/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */

// Seg0

// Seg1

/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */

/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */

/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */

/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */

/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */

/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */

/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */

/**
 * @author Yi Shen(https://github.com/pissang)
 */

/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */

/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

// Is a circle

// Thresh to [0, Math.PI * 2]

// var number = 0;

// var step = (anticlockwise ? -Math.PI : Math.PI) / 2;

/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */

// TODO getTotalLength, getPointAtLength

// Rect

/**
         * Path data. Stored as flat array
         * @type {Array.<Object>}
         */

// var CMD_MEM_SIZE = {

//     M: 3,

//     L: 3,

//     C: 7,

//     Q: 5,

//     A: 9,

//     R: 5,

//     Z: 1

// };

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */

// Quick reject

/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */

// http://pomax.github.io/bezierinfo/#projections

// 先粗略估计一下可能的最小距离的 t 值

// At most 32 iteration

// t - interval

// t + interval

// t

// console.log(interval, i);

/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */

/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */

// Unit x, Unit y. Provide for avoiding drawing that too short line segment

/**
     * @readOnly
     */

/**
     * @param  {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */

// Reset

/**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */

// x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用

// xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。

// 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要

// 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

/**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @return {module:zrender/core/PathProxy}
     */

/**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {module:zrender/core/PathProxy}
     */

/**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} r
     * @param  {number} startAngle
     * @param  {number} endAngle
     * @param  {boolean} anticlockwise
     * @return {module:zrender/core/PathProxy}
     */

/**
     * @return {module:zrender/core/PathProxy}
     */

/**
     * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
     * stroke 同样
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */

/**
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */

/**
     * 必须在其它绘制命令前调用
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */

/**
     *
     * @return {boolean}
     */

/**
     * 直接设置 Path 数据
     */

/**
     * 添加子路径
     * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
     */

/**
     * 填充 Path 数据。
     * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
     */

// 因为之前的数组已经转换成静态的 Float32Array

// 所以不够用时需要扩展一个新的动态数组

// Only if data is Float32Array

/**
     * If needs js implemented dashed line
     * @return {boolean}
     * @private
     */

// Convert to positive offset

// Skip positive offset

// Offset for next lineTo

// Not accurate dashed line to

// Bezier approx length

// Find idx after add offset

// Use line to approximate dashed bezier

// Bad result if dash is long

// Finish the last segment and calculate the new offset

// Convert quadratic to cubic using degree elevation

/**
     * 转成静态的 Float32Array 减少堆内存占用
     * Convert dynamic array to static Float32Array
     */

// 如果第一个命令是 L, C, Q

// 则 previous point 同绘制命令的第一个 point

//

// 第一个命令为 Arc 的情况下会在后面特殊处理

// moveTo 命令重新创建一个新的 subpath, 并且更新新的起点

// 在 closePath 的时候使用

// TODO Arc 判断的开销比较大

// TODO Arc 旋转

// 直接使用 arc 命令

// 第一个命令起点还未定义

// Use fromLine

// Union

// No data

/**
     * Rebuild path from current data
     * Rebuild path will not consider javascript implemented line dash.
     * @param {CanvasRenderingContext2D} ctx
     */

// Not draw too small seg between

/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */

// Ignore horizontal line

// Avoid winding error when intersection point is the connect point of two line of polygon

// If (x, y) on the line, considered as "contain".

// 临时数组

// Evaluate roots of cubic functions

//t1, t2, t3, b is not zero

// t2, t3

// 分成三段单调函数

// 分成两段单调函数

// Remove one endpoint.

// Arc 旋转

// Begin a new subpath

// Close previous subpath

// NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN

// 不是直接使用 arc 命令

// zr 使用scale来模拟椭圆, 这里也对x做一定的缩放

// FIXME Clockwise ?

// Close a subpath

// 如果被任何一个 subpath 包含

// FIXME subpaths may overlap

// if (w !== 0) {

//     return true;

/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

/**
     * @type {module:zrender/core/PathProxy}
     * @readOnly
     */

/**
     * See `module:zrender/src/graphic/helper/subPixelOptimize`.
     * @type {boolean}
     */

// Update gradient because bounding rect may changed

// Use the gradient or pattern

// PENDING If may have affect the state

// Proxy context

// Rebuild path in following 2 cases

// 1. Path is dirty

// 2. Path needs javascript implemented lineDash stroking.

//    In this case, lineDash information will not be saved in PathProxy

// Setting line dash before build path

// Clear path dirty flag

// Replay path building

// Remove lineDash

// When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath

// Like in circle

// Create path on demand.

// Needs update rect with stroke lineWidth when

// 1. Element changes scale or lineWidth

// 2. Shape is changed

// FIXME Must after updateTransform

// PENDING, Min line width is needed when line is horizontal or vertical

// Only add extra hover lineWidth when there are no fill

// Consider line width

// Line scale can't be 0;

// Return rect with stroke

/**
     * @param  {boolean} dirtyPath
     */

// Only mark dirty, not mark clean

// Used as a clipping path

/**
     * Alias for animate('shape')
     * @param {boolean} loop
     */

// Overwrite attrKV

// Path from string may not have shape

// Get the line scale.

// Determinant of `m` means how much the area is enlarged by the

// transformation. So its square root can be used as a scale factor

// for width.

/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

// Extend default style

// Extend default shape

// FIXME 不能 extend position, rotation 等引用对象

// Extending prototype values and methods

// cx

// cy

// Scale rx and ry

// FIXME Assume psi is 0 here

// Start angle

// end angle

// FIXME psi

// x0, y0

// x1, y1

// Write back

// Consider case:

// (1) delimiter can be comma or space, where continuous commas

// or spaces should be seen as one comma.

// (2) value can be like:

// '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',

// 'l-.5E1,54', '121-23-44-11' (no delimiter)

// TODO Optimize double memory cost problem

// var valueSplitReg = /[\s,]+/;

// var data = data.replace(/-/g, ' -')

//     .replace(/  /g, ' ')

//     .replace(/ /g, ',')

//     .replace(/,,/g, ',');

// var n;

// create pipes so that we can split the data

// for (n = 0; n < cc.length; n++) {

//     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);

// data = data.replace(/-/g, ',-');

// create array

// var arr = cs.split('|');

// init context point

// convert l, H, h, V, and v to L

// z may be in the middle of the path.

/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */

/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */

/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

// Use props with prefix 'text'.

// Do not apply style.bind in Text node. Because the real bind job

// is in textHelper.renderText, and performance of text render should

// be considered.

// style.bind(ctx, this, prevEl);

// The current el.style is not applied

// and should not be used as cache.

// version string can be: '11.0'

// It is save to put shadowTemp static, because shadowTemp

// will be all modified each item brush called.

/**
 * 圆形
 * @module zrender/shape/Circle
 */

// Better stroking in ShapeBundle

// Always do it may have performence issue ( fill may be 2x more cost)

// else {

//     if (ctx.allocate && !ctx.data.length) {

//         ctx.allocate(ctx.CMD_MEM_SIZE.A);

// ctx.moveTo(shape.cx + shape.r, shape.cy);

// Fix weird bug in some version of IE11 (like 11.0.9600.178**),

// where exception "unexpected call to method or property access"

// might be thrown when calling ctx.fill or ctx.stroke after a path

// whose area size is zero is drawn and ctx.clip() is called and

// shadowBlur is set. See #4572, #3112, #5777.

// (e.g.,

//  ctx.moveTo(10, 10);

//  ctx.lineTo(20, 10);

//  ctx.closePath();

//  ctx.clip();

//  ctx.shadowBlur = 10;

//  ...

//  ctx.fill();

// )

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * @inner
 */

/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */

// 与指定的包围盒做并集

// use degree to scale the handle length

/**
 * 多边形
 * @module zrender/shape/Polygon
 */

/**
 * @module zrender/graphic/shape/Polyline
 */

/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth Should be nonnegative integer.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */

// Assure that (position + lineWidth / 2) is near integer edge,

// otherwise line will be fuzzy in canvas.

/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */

// Avoid create repeatly.

// 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4

// r缩写为1         相当于 [1, 1, 1, 1]

// r缩写为[1]       相当于 [1, 1, 1, 1]

// r缩写为[1, 2]    相当于 [1, 2, 1, 2]

// r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]

/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} outputShape The modification will be performed on `outputShape`.
 *                 `outputShape` and `inputShape` can be the same object.
 *                 `outputShape` object can be used repeatly, because all of
 *                 the `x`, `y`, `width`, `height` will be assigned in this method.
 * @param {Object} [inputShape]
 * @param {number} [inputShape.x]
 * @param {number} [inputShape.y]
 * @param {number} [inputShape.width]
 * @param {number} [inputShape.height]
 * @param {Object} [style]
 * @param {number} [style.lineWidth]
 */

// Start point

// End point

/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} outputShape The modification will be performed on `outputShape`.
 *                 `outputShape` and `inputShape` can be the same object.
 *                 `outputShape` object can be used repeatly, because all of
 *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.
 * @param {Object} [inputShape]
 * @param {number} [inputShape.x1]
 * @param {number} [inputShape.y1]
 * @param {number} [inputShape.x2]
 * @param {number} [inputShape.y2]
 * @param {Object} [style]
 * @param {number} [style.lineWidth]
 */

/**
     * Get point at percent
     * @param  {number} percent
     * @return {Array.<number>}
     */

// cpx2: 0,

// cpy2: 0

// Curve show percent, for animating

/**
     * Get point at percent
     * @param  {number} t
     * @return {Array.<number>}
     */

/**
     * Get tangent at percent
     * @param  {number} t
     * @return {Array.<number>}
     */

// Mark as dirty if any subpath is dirty

// Update path scale

/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */

// declard by `color: {type: 'linear', colorStops: ...}`, where

// this constructor will not be called.

// If use global coord

// declard by `color: {type: 'radial', colorStops: ...}`, where

/**
 * Displayable for incremental rendering. It will be rendered in a separate layer
 * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`
 * addDisplayables will render the added displayables incremetally.
 *
 * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
 */

// TODO Style override ?

// Render persistant displayables.

// Render temporary displayables.

/**
 * Extend shape with parameters
 */

/**
 * Extend path
 */

/**
 * Create a path element from path data string
 * @param {string} pathData
 * @param {Object} opts
 * @param {module:zrender/core/BoundingRect} rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */

/**
 * Create a image element from image url
 * @param {string} imageUrl image url
 * @param {Object} opts options
 * @param {module:zrender/core/BoundingRect} rect constrain rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */

/**
 * Get position of centered element in bounding box.
 *
 * @param  {Object} rect         element local bounding box
 * @param  {Object} boundingRect constraint bounding box
 * @return {Object} element position containing x, y, width, and height
 */

// Set rect to center, keep width / height ratio.

/**
 * Merge multiple paths
 */

// TODO Apply transform

// TODO stroke dash

// Need path proxy.

// Svg and vml renderer don't have context

/**
 * Resize a path to fit the rect
 * @param {module:zrender/graphic/Path} path
 * @param {Object} rect
 */

/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x1]
 * @param {number} [param.shape.y1]
 * @param {number} [param.shape.x2]
 * @param {number} [param.shape.y2]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */

/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x]
 * @param {number} [param.shape.y]
 * @param {number} [param.shape.width]
 * @param {number} [param.shape.height]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */

// Most lifted color are duplicated.

// See comment in `doSingleEnterHover`.

// Always cache fill and stroke to normalStyle for lifting color.

// styles can be:

// {

//    label: {

//        show: false,

//        position: 'outside',

//        fontSize: 18

//    },

//    emphasis: {

//        label: {

//            show: true

//        }

//    }

// where properties of `emphasis` may not appear in `normal`. We previously use

// module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.

// But consider rich text and setOption in merge mode, it is impossible to cover

// all properties in merge. So we use merge mode when setting style here, where

// only properties that is not `null/undefined` can be set. The disadventage:

// null/undefined can not be used to remove style any more in `emphasis`.

// Consider null/undefined value, should use

// `setStyle` but not `extendFrom(stl, true)`.

// `__cachedNormalZ2` will not be reset if calling `setElementHoverStyle`

// when `el` is on emphasis state. So here by comparing with 1, we try

// hard to make the bug case rare.

/**
 * Set hover style (namely "emphasis style") of element, based on the current
 * style of the given `el`.
 * This method should be called after all of the normal styles have been adopted
 * to the `el`. See the reason on `setHoverStyle`.
 *
 * @param {module:zrender/Element} el Should not be `zrender/container/Group`.
 * @param {Object|boolean} [hoverStl] The specified hover style.
 *        If set as `false`, disable the hover style.
 *        Similarly, The `el.hoverStyle` can alse be set
 *        as `false` to disable the hover style.
 *        Otherwise, use the default hover style if not provided.
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false] See `graphic.setAsHoverStyleTrigger`
 */

// For performance consideration, it might be better to make the "hover style" only the

// difference properties from the "normal style", but not a entire copy of all styles.

// It is not completely right to save "normal"/"emphasis" flag on elements.

// It probably should be saved on `data` of series. Consider the cases:

// (1) A highlighted elements are moved out of the view port and re-enter

// again by dataZoom.

// (2) call `setOption` and replace elements totally when they are highlighted.

// Consider the case:

// The styles of a highlighted `el` is being updated. The new "emphasis style"

// should be adapted to the `el`. Notice here new "normal styles" should have

// been set outside and the cached "normal style" is out of date.

// Do not clear `__cachedNormalZ2` here, because setting `z2` is not a constraint

// of this method. In most cases, `z2` is not set and hover style should be able

// to rollback. Of course, that would bring bug, but only in a rare case, see

// `doSingleLeaveHover` for details.

/**
 * Emphasis (called by API) has higher priority than `mouseover`.
 * When element has been called to be entered emphasis, mouse over
 * should not trigger the highlight effect (for example, animation
 * scale) again, and `mouseout` should not downplay the highlight
 * effect. So the listener of `mouseover` and `mouseout` should
 * check `isInEmphasis`.
 *
 * @param {module:zrender/Element} el
 * @return {boolean}
 */

// Only if element is not in emphasis status

/**
 * Set hover style (namely "emphasis style") of element,
 * based on the current style of the given `el`.
 *
 * (1)
 * **CONSTRAINTS** for this method:
 * <A> This method MUST be called after all of the normal styles having been adopted
 * to the `el`.
 * <B> The input `hoverStyle` (that is, "emphasis style") MUST be the subset of the
 * "normal style" having been set to the el.
 * <C> `color` MUST be one of the "normal styles" (because color might be lifted as
 * a default hover style).
 *
 * The reason: this method treat the current style of the `el` as the "normal style"
 * and cache them when enter/update the "emphasis style". Consider the case: the `el`
 * is in "emphasis" state and `setOption`/`dispatchAction` trigger the style updating
 * logic, where the el should shift from the original emphasis style to the new
 * "emphasis style" and should be able to "downplay" back to the new "normal style".
 *
 * Indeed, it is error-prone to make a interface has so many constraints, but I have
 * not found a better solution yet to fit the backward compatibility, performance and
 * the current programming style.
 *
 * (2)
 * Call the method for a "root" element once. Do not call it for each descendants.
 * If the descendants elemenets of a group has itself hover style different from the
 * root group, we can simply mount the style on `el.hoverStyle` for them, but should
 * not call this method for them.
 *
 * @param {module:zrender/Element} el
 * @param {Object|boolean} [hoverStyle] See `graphic.setElementHoverStyle`.
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false] See `graphic.setAsHoverStyleTrigger`.
 */

// If element has sepcified hoverStyle, then use it instead of given hoverStyle

// Often used when item group has a label element and it's hoverStyle is different

/**
 * @param {Object|boolean} [opt] If `false`, means disable trigger.
 * @param {boolean} [opt.hoverSilentOnTouch=false]
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conveniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
 *        on touch device.
 */

// Simple optimize, since this method might be

// called for each elements of a group in some cases.

// Duplicated function will be auto-ignored, see Eventful.js.

// Emphasis, normal can be triggered manually

/**
 * See more info in `setTextStyleCommon`.
 * @param {Object|module:zrender/graphic/Style} normalStyle
 * @param {Object} emphasisStyle
 * @param {module:echarts/model/Model} normalModel
 * @param {module:echarts/model/Model} emphasisModel
 * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
 * @param {string|Function} [opt.defaultText]
 * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
 *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {Object} [normalSpecified]
 * @param {Object} [emphasisSpecified]
 */

// Optimize: If style.text is null, text will not be drawn.

// Always set `textStyle` even if `normalStyle.text` is null, because default

// values have to be set on `normalStyle`.

// If we set default values on `emphasisStyle`, consider case:

// Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`

// Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`

// Then the 'red' will not work on emphasis.

/**
 * Set basic textStyle properties.
 * See more info in `setTextStyleCommon`.
 * @param {Object|module:zrender/graphic/Style} textStyle
 * @param {module:echarts/model/Model} model
 * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
 * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
 * @param {boolean} [isEmphasis]
 */

// textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

/**
 * Set text option in the style.
 * See more info in `setTextStyleCommon`.
 * @deprecated
 * @param {Object} textStyle
 * @param {module:echarts/model/Model} labelModel
 * @param {string|boolean} defaultColor Default text color.
 *        If set as false, it will be processed as a emphasis style.
 */

/**
 * The uniform entry of set text style, that is, retrieve style definitions
 * from `model` and set to `textStyle` object.
 *
 * Never in merge mode, but in overwrite mode, that is, all of the text style
 * properties will be set. (Consider the states of normal and emphasis and
 * default value can be adopted, merge would make the logic too complicated
 * to manage.)
 *
 * The `textStyle` object can either be a plain object or an instance of
 * `zrender/src/graphic/Style`, and either be the style of normal or emphasis.
 * After this mothod called, the `textStyle` object can then be used in
 * `el.setStyle(textStyle)` or `el.hoverStyle = textStyle`.
 *
 * Default value will be adopted and `insideRollbackOpt` will be created.
 * See `applyDefaultTextStyle` `rollbackDefaultTextStyle` for more details.
 *
 * opt: {
 *      disableBox: boolean, Whether diable drawing box of block (outer most).
 *      isRectText: boolean,
 *      autoColor: string, specify a color when color is 'auto',
 *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
 *              If autoColor specified, it is used as default textFill.
 *      useInsideStyle:
 *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
 *                  if `textFill` is not specified.
 *              `false`: Do not use inside style.
 *              `null/undefined`: use inside style if `isRectText` is true and
 *                  `textFill` is not specified and textPosition contains `'inside'`.
 *      forceRich: boolean
 * }
 */

// Consider there will be abnormal when merge hover style to normal style if given default value.

// 'outside' is not a valid zr textPostion value, but used

// in bar series, and magric type should be considered.

//     data: [{

//         value: 12,

//         label: {

//             rich: {

//                 // no 'a' here but using parent 'a'.

//         }

//     }],

//     rich: {

//         a: { ... }

// Use object to remove duplicated names.

// Cascade is supported in rich.

// In rich, never `disableBox`.

// In merge mode, default value should not be given.

// Save original textPosition, because style.textPosition will be repalced by

// real location (like [10, 30]) in zrender.

// Set default finally.

// Do not use `getFont` here, because merge should be supported, where

// part of these properties may be changed in emphasis style, and the

// others should remain their original value got from normal style.

/**
 * Give some default value to the input `textStyle` object, based on the current settings
 * in this `textStyle` object.
 *
 * The Scenario:
 * when text position is `inside` and `textFill` is not specified, we show
 * text border by default for better view. But it should be considered that text position
 * might be changed when hovering or being emphasis, where the `insideRollback` is used to
 * restore the style.
 *
 * Usage (& NOTICE):
 * When a style object (eithor plain object or instance of `zrender/src/graphic/Style`) is
 * about to be modified on its text related properties, `rollbackDefaultTextStyle` should
 * be called before the modification and `applyDefaultTextStyle` should be called after that.
 * (For the case that all of the text related properties is reset, like `setTextStyleCommon`
 * does, `rollbackDefaultTextStyle` is not needed to be called).
 */

// Only `insideRollbackOpt` created (in `setTextStyleCommon`),

// applyDefaultTextStyle works.

// Consider text with #fff overflow its container.

// Always set `insideRollback`, for clearing previous.

/**
 * Consider the case: in a scatter,
 * label: {
 *     normal: {position: 'inside'},
 *     emphasis: {position: 'top'}
 * }
 * In the normal state, the `textFill` will be set as '#fff' for pretty view (see
 * `applyDefaultTextStyle`), but when switching to emphasis state, the `textFill`
 * should be retured to 'autoColor', but not keep '#fff'.
 */

// ecModel or default text style model.

/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} [cb]
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */

/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} cb
 */

/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param {module:zrender/mixin/Transformable} target
 * @param {module:zrender/mixin/Transformable} [ancestor]
 */

/**
 * Apply transform to an vertex.
 * @param {Array.<number>} target [x, y]
 * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param {boolean=} invert Whether use invert matrix.
 * @return {Array.<number>} [x, y]
 */

/**
 * @param {string} direction 'left' 'right' 'top' 'bottom'
 * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param {boolean=} invert Whether use invert matrix.
 * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
 */

// Pick a base, ensure that transform result will not be (0, 0).

/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */

//     if (el.previousProps) {

//         graphic.updateProps

/**
 * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
 * @param {Object} rect {x, y, width, height}
 * @return {Array.<Array.<number>>} A new clipped points.
 */

// FIXME: this way migth be incorrect when grpahic clipped by a corner.

// and when element have border.

/**
 * @param {Object} targetRect {x, y, width, height}
 * @param {Object} rect {x, y, width, height}
 * @return {Object} A new clipped rect. If rect size are negative, return undefined.
 */

/**
 * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
 * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
 * @param {Object} [rect] {x, y, width, height}
 * @return {module:zrender/Element} Icon path or image element.
 */

// Support setting color as 'auto' to get visual color.

// If the total rect is cliped, nothing, including the border,

// should be painted. So return undefined.

/**
     * Get color property or get color from option.textStyle.color
     * @param {boolean} [isEmphasis]
     * @return {string}
     */

/**
     * Create font string from fontStyle, fontWeight, fontSize, fontFamily
     * @return {string}
     */

/**
 * @alias module:echarts/model/Model
 * @constructor
 * @param {Object} [option]
 * @param {module:echarts/model/Model} [parentModel]
 * @param {module:echarts/model/Global} [ecModel]
 */

/**
     * @type {module:echarts/model/Model}
     * @readOnly
     */

/**
     * @type {module:echarts/model/Global}
     * @readOnly
     */

/**
     * @type {Object}
     * @protected
     */

// obj could be number/string/... (like 0)

// `path` can be null/undefined

// Enable Model.extend.

/**
     * Model 的初始化函数
     * @param {Object} option
     */

/**
     * 从新的 Option merge
     */

/**
     * @param {string|Array.<string>} path
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */

/**
     * @param {string} key
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */

/**
     * @param {string|Array.<string>} [path]
     * @param {module:echarts/model/Model} [parentModel]
     * @return {module:echarts/model/Model}
     */

/**
     * If model has option
     */

// Pending

// clazzUtil.setReadOnly(this, properties);

// If path is null/undefined, return null/undefined.

/**
     * @param {Function} getParentMethod
     *        param {Array.<string>|string} path
     *        return {module:echarts/model/Model}
     */

/**
 * @public
 * @param {string} type
 * @return {string}
 */

// Considering the case of crossing js context,

// use Math.random to make id as unique as possible.

/*
* A third-party license is embeded for some of the code in this file:
* The method "quantile" was copied from "d3.js".
* (See more details in the comment of the method below.)
* The use of the source code of this file is also subject to the terms
* and consitions of the license of "d3.js" (BSD-3Clause, see
* </licenses/LICENSE-d3>).
*/

/**
 * Linear mapping a value from domain to range
 * @memberOf module:echarts/util/number
 * @param  {(number|Array.<number>)} val
 * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
 * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
 * @param  {boolean} clamp
 * @return {(number|Array.<number>}
 */

// Avoid accuracy problem in edge, such as

// 146.39 - 62.83 === 83.55999999999999.

// See echarts/test/ut/spec/util/number.js#linearMap#accuracyError

// It is a little verbose for efficiency considering this method

// is a hotspot.

/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 * @memberOf module:echarts/util/number
 * @param {string|number} percent
 * @param {number} all
 * @return {number}
 */

/**
 * (1) Fix rounding error of float numbers.
 * (2) Support return string to avoid scientific notation like '3.5e-7'.
 *
 * @param {number} x
 * @param {number} [precision]
 * @param {boolean} [returnStr]
 * @return {number|string}
 */

// Avoid range error

/**
 * Get precision
 * @param {number} val
 */

// It is much faster than methods converting number to string as follows

//      var tmp = val.toString();

//      return tmp.length - 1 - tmp.indexOf('.');

// especially when precision is low

/**
 * @param {string|number} val
 * @return {number}
 */

// Consider scientific notation: '3.4e-12' '3.4e+12'

/**
 * Minimal dicernible data precisioin according to a single pixel.
 *
 * @param {Array.<number>} dataExtent
 * @param {Array.<number>} pixelExtent
 * @return {number} precision
 */

/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param {Array.<number>} valueList a list of all data
 * @param {number} idx index of the data to be processed in valueList
 * @param {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */

// Has remainding votes.

// Assign automatic seats.

// Find next largest remainder.

// Add a vote to max remainder.

// Number.MAX_SAFE_INTEGER, ie do not support.

/**
 * To 0 - 2 * PI, considering negative radian.
 * @param {number} radian
 * @return {number}
 */

/**
 * @param {type} radian
 * @return {boolean}
 */

/* eslint-disable */

/* eslint-enable */

/**
 * @param {string|Date|number} value These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return {Date} date
 */

// Different browsers parse date in different way, so we parse it manually.

// Some other issues:

// new Date('1970-01-01') is UTC,

// new Date('1970/01/01') and new Date('1970-1-01') is local.

// See issue #3623

// return Invalid Date.

// Use local time when no timezone offset specifed.

// match[n] can only be string or undefined.

// But take care of '12' + 1 => '121'.

/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param  {number} val
 * @return {number}
 */

/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  {number} val Non-negative value.
 * @param  {boolean} round
 * @return {number}
 */

// Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).

// 20 is the uppper bound of toFixed.

/**
 * This code was copied from "d3.js"
 * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
 * See the license statement at the head of this file.
 * @param {Array.<number>} ascArr
 */

/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param {Array.<Object>} list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return {Array.<Object>} The origin list, which has been reformed.
 */

/**
 * parseFloat NaNs numeric-cast false positives (null|true|false|"")
 * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 * subtraction forces infinities to NaN
 *
 * @param {*} v
 * @return {boolean}
 */

// import Text from 'zrender/src/graphic/Text';

/**
 * 每三位默认加,格式化
 * @param {string|number} x
 * @return {string}
 */

/**
 * @param {string} str
 * @param {boolean} [upperCaseFirst=false]
 * @return {string} str
 */

/**
 * Template formatter
 * @param {string} tpl
 * @param {Array.<Object>|Object} paramsList
 * @param {boolean} [encode=false]
 * @return {string}
 */

/**
 * simple Template formatter
 *
 * @param {string} tpl
 * @param {Object} param
 * @param {boolean} [encode=false]
 * @return {string}
 */

/**
 * @param {Object|string} [opt] If string, means color.
 * @param {string} [opt.color]
 * @param {string} [opt.extraCssText]
 * @param {string} [opt.type='item'] 'item' or 'subItem'
 * @param {string} [opt.renderMode='html'] render mode of tooltip, 'html' or 'richText'
 * @param {string} [opt.markerId='X'] id name for marker. If only one marker is in a rich text, this can be omitted.
 * @return {string}
 */

/**
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */

/**
 * Capital first
 * @param {string} str
 * @return {string}
 */

/**
 * @public
 * @param {Object} opt
 * @param {string} opt.text
 * @param {string} opt.font
 * @param {string} [opt.textAlign='left']
 * @param {string} [opt.textVerticalAlign='top']
 * @param {Array.<number>} [opt.textPadding]
 * @param {number} [opt.textLineHeight]
 * @param {Object} [opt.rich]
 * @param {Object} [opt.truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */

/**
 * @deprecated
 * the `textLineHeight` was added later.
 * For backward compatiblility, put it as the last parameter.
 * But deprecated this interface. Please use `getTextBoundingRect` instead.
 */

// Layout helpers for each component positioning

// Wrap when width exceeds maxWidth or meet a `newline` group

// FIXME compare before adding gap?

// Wrap when width exceeds maxHeight or meet a `newline` group

/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

/**
 * VBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

/**
 * If x or x2 is not specified or 'center' 'left' 'right',
 * the width would be as long as possible.
 * If y or y2 is not specified or 'middle' 'top' 'bottom',
 * the height would be as long as possible.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.x]
 * @param {number|string} [positionInfo.y]
 * @param {number|string} [positionInfo.x2]
 * @param {number|string} [positionInfo.y2]
 * @param {Object} containerRect {width, height}
 * @param {string|number} margin
 * @return {Object} {width, height}
 */

/**
 * Parse position info.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width]
 * @param {number|string} [positionInfo.height]
 * @param {number|string} [positionInfo.aspect] Aspect is width / height
 * @param {Object} containerRect
 * @param {string|number} [margin]
 *
 * @return {module:zrender/core/BoundingRect}
 */

// Align left and top

// If width is not specified, calculate width from left and right

// If width and height are not given

// 1. Graph should not exceeds the container

// 2. Aspect must be keeped

// 3. Graph should take the space as more as possible

// Margin is not considered, because there is no case that both

// using margin and aspect so far.

// Calculate width or height with given aspect

// If left is not specified, calculate left from right and width

// If something is wrong and left, top, width, height are calculated as NaN

// Width may be NaN if only one value is given except width

// Height may be NaN if only one value is given except height

/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * @param {module:zrender/Element} el Should have `getBoundingRect` method.
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
 * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
 * @param {Object} containerRect
 * @param {string|number} margin
 * @param {Object} [opt]
 * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
 * @param {Array.<number>} [opt.boundingMode='all']
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */

// Notice: raw rect may be inner object of el,

// which should not be modified.

// The real width and height can not be specified but calculated by the given el.

// Because 'tranlate' is the last step in transform

// (see zrender/core/Transformable#getLocalTransform),

// we can just only modify el.position to get final result.

/**
 * @param {Object} option Contains some of the properties in HV_NAMES.
 * @param {number} hvIdx 0: horizontal; 1: vertical.
 */

/**
 * Consider Case:
 * When defulat option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         var inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param {Object} targetOption
 * @param {Object} newOption
 * @param {Object|string} [opt]
 * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
 *  that width (or height) should not be calculated by left and right (or top and bottom).
 */

// Consider case: newOption.width is null, which is

// set by user for removing width setting.

// Only one of left/right is premitted to exist.

// Case: newOption: {width: ..., right: ...},

// or targetOption: {right: ...} and newOption: {width: ...},

// There is no conflict when merged only has params count

// little than enoughParamNumber.

// Chose another param from targetOption by priority.

/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */

/**
     * @readOnly
     * @type {string}
     */

/**
     * Because simplified concept is probably better, series.name (or component.name)
     * has been having too many resposibilities:
     * (1) Generating id (which requires name in option should not be modified).
     * (2) As an index to mapping series when merging option or calling API (a name
     * can refer to more then one components, which is convinient is some case).
     * (3) Display.
     * @readOnly
     */

/**
     * @readOnly
     * @type {number}
     */

/**
     * key: componentType
     * value:  Component model list, can not be null.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @readOnly
     */

/**
     * @type {string}
     * @readOnly
     */

/**
     * Support merge layout params.
     * Only support 'box' now (left/right/top/bottom/width/height).
     * @type {string|Object} Object can be {ignoreSize: true}
     * @readOnly
     */

// Hooker after init or mergeOption

/**
 * Component model
 *
 * @module echarts/model/Component
 */

// Reset ComponentModel.extend, add preConstruct.

// clazzUtil.enableClassExtend(

//     ComponentModel,

//     function (option, parentModel, ecModel, extraOpt) {

//         // Set dependentModels, componentIndex, name, id, mainType, subType.

//         zrUtil.extend(this, extraOpt);

//         this.uid = componentUtil.getUID('componentModel');

//         // this.setReadOnly([

//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',

//         //     'dependentModels', 'componentIndex'

//         // ]);

// );

// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

// Add capability of ComponentModel.topologicalTravel.

// Hack dataset for convenience.

// Ensure main type.

/**
     * @public
     * @param {Array.<string>} targetNameList Target Component type list.
     *                                           Can be ['aa', 'bb', 'aa.xx']
     * @param {Array.<string>} fullNameList By which we can build dependency graph.
     * @param {Function} callback Params: componentType, dependencies.
     * @param {Object} context Scope of callback.
     */

/**
     * DepndencyGraph: {Object}
     * key: conponentType,
     * value: {
     *     successor: [conponentTypes...],
     *     originalDeps: [conponentTypes...],
     *     entryCount: {number}
     * }
     */

// Consider this case: legend depends on series, and we call

// chart.setOption({series: [...]}), where only series is in option.

// If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will

// not be called, but only sereis.mergeOption is called. Thus legend

// have no chance to update its local record about series (like which

// name of series is available in legend).

// Navigator not exists in node

// backgroundColor: 'rgba(0,0,0,0)',

// https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization

// color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],

// Light colors:

// color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],

// color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],

// Dark colors:

// If xAxis and yAxis declared, grid is created by default.

// grid: {},

// color: '#000',

// decoration: 'none',

// fontFamily: 'Arial, Verdana, sans-serif',

// http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/

// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation

// Default is source-over

// Configuration for progressive/incremental rendering

// Threshold of if use single hover layer to optimize.

// It is recommended that `hoverLayerThreshold` is equivalent to or less than

// `progressiveThreshold`, otherwise hover will cause restart of progressive,

// which is unexpected.

// see example <echarts/test/heatmap-large.html>.

// See: module:echarts/scale/Time

/**
     * @param {string} name MUST NOT be null/undefined. Otherwise call this function
     *                 twise with the same parameters will get different result.
     * @param {Object} [scope=this]
     * @param {Object} [requestColorNum]
     * @return {string} color string.
     */

// Use `hasOwnProperty` to avoid conflict with Object.prototype.

// TODO colors must be in order

// In case can't find in layered color palette.

/**
 * Helper for model references.
 * There are many manners to refer axis/coordSys.
 */

// merge relevant logic to this file?

// check: "modelHelper" of tooltip and "BrushTargetManager".

/**
 * @return {Object} For example:
 * {
 *     coordSysName: 'cartesian2d',
 *     coordSysDims: ['x', 'y', ...],
 *     axisMap: HashMap({
 *         x: xAxisModel,
 *         y: yAxisModel
 *     }),
 *     categoryAxisMap: HashMap({
 *         x: xAxisModel,
 *         y: undefined
 *     }),
 *     // It also indicate that whether there is category axis.
 *     firstCategoryDimIndex: 1,
 *     // To replace user specified encode.
 * }
 */

// Avoid typo.

/**
 * [sourceFormat]
 *
 * + "original":
 * This format is only used in series.data, where
 * itemStyle can be specified in data item.
 *
 * + "arrayRows":
 * [
 *     ['product', 'score', 'amount'],
 *     ['Matcha Latte', 89.3, 95.8],
 *     ['Milk Tea', 92.1, 89.4],
 *     ['Cheese Cocoa', 94.4, 91.2],
 *     ['Walnut Brownie', 85.4, 76.9]
 * ]
 *
 * + "objectRows":
 * [
 *     {product: 'Matcha Latte', score: 89.3, amount: 95.8},
 *     {product: 'Milk Tea', score: 92.1, amount: 89.4},
 *     {product: 'Cheese Cocoa', score: 94.4, amount: 91.2},
 *     {product: 'Walnut Brownie', score: 85.4, amount: 76.9}
 * ]
 *
 * + "keyedColumns":
 * {
 *     'product': ['Matcha Latte', 'Milk Tea', 'Cheese Cocoa', 'Walnut Brownie'],
 *     'count': [823, 235, 1042, 988],
 *     'score': [95.8, 81.4, 91.2, 76.9]
 * }
 *
 * + "typedArray"
 *
 * + "unknown"
 */

/**
 * @constructor
 * @param {Object} fields
 * @param {string} fields.sourceFormat
 * @param {Array|Object} fields.fromDataset
 * @param {Array|Object} [fields.data]
 * @param {string} [seriesLayoutBy='column']
 * @param {Array.<Object|string>} [dimensionsDefine]
 * @param {Objet|HashMap} [encodeDefine]
 * @param {number} [startIndex=0]
 * @param {number} [dimensionsDetectCount]
 */

/**
     * Not null/undefined.
     * @type {Array|Object}
     */

/**
     * See also "detectSourceFormat".
     * Not null/undefined.
     * @type {string}
     */

/**
     * 'row' or 'column'
     * Not null/undefined.
     * @type {string} seriesLayoutBy
     */

/**
     * dimensions definition in option.
     * can be null/undefined.
     * @type {Array.<Object|string>}
     */

/**
     * encode definition in option.
     * can be null/undefined.
     * @type {Objet|HashMap}
     */

/**
     * Not null/undefined, uint.
     * @type {number}
     */

/**
     * Can be null/undefined (when unknown), uint.
     * @type {number}
     */

/**
 * Wrap original series data for some compatibility cases.
 */

/**
 * @see {module:echarts/data/Source}
 * @param {module:echarts/component/dataset/DatasetModel} datasetModel
 * @return {string} sourceFormat
 */

/**
 * [Caution]:
 * MUST be called after series option merged and
 * before "series.getInitailData()" called.
 *
 * [The rule of making default encode]:
 * Category axis (if exists) alway map to the first dimension.
 * Each other axis occupies a subsequent dimension.
 *
 * [Why make default encode]:
 * Simplify the typing of encode in option, avoiding the case like that:
 * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],
 * where the "y" have to be manually typed as "1, 2, 3, ...".
 *
 * @param {module:echarts/model/Series} seriesModel
 */

/**
 * If return null/undefined, indicate that should not use datasetModel.
 */

// Caution: consider the scenario:

// A dataset is declared and a series is not expected to use the dataset,

// and at the beginning `setOption({series: { noData })` (just prepare other

// option but no data), then `setOption({series: {data: [...]}); In this case,

// the user should set an empty array to avoid that dataset is used by default.

/**
 * The rule should not be complex, otherwise user might not
 * be able to known where the data is wrong.
 * The code is ugly, but how to make it neat?
 *
 * @param {module:echars/data/Source} source
 * @param {number} dimIndex
 * @return {boolean} Whether ordinal.
 */

// These settings from series has higher priority.

// return {startIndex, dimensionsDefine, dimensionsCount}

// Rule: Most of the first line are string: it is header.

// Caution: consider a line with 5 string and 1 number,

// it still can not be sure it is a head, because the

// 5 string may be 5 values of category columns.

// '-' is regarded as null/undefined.

// 10 is an experience number, avoid long loop.

// jshint ignore: line

// ??? TODO merge to completedimensions, where also has

// default encode making logic. And the default rule

// should depends on series? consider 'map'.

// Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],

// which is reasonable. But dimension name is duplicated.

// Returns undefined or an array contains only object without null/undefiend or string.

// Note: dataset option does not have `encode`.

// Usually in this case series will use the first data

// dimension as the "value" dimension, or other default

// processes respectively.

// Auto detect first time axis and do arrangement.

// In value way.

// ??? TODO give a better default series name rule?

// especially when encode x y specified.

// consider: when mutiple series share one dimension

// category axis, series name should better use

// the other dimsion name. On the other hand, use

// both dimensions name.

// In category way, category axis.

// encodeTooltip.push(dataDim);

// encodeLabel.push(dataDim);

// Do not make a complex rule! Hard to code maintain and not necessary.

// ??? TODO refactor: provide by series itself.

// [{name: ..., value: ...}, ...] like:

// Find the first not ordinal. (5 is an experience value)

// By default, label use itemName in charts.

// So we dont set encodeLabel here.

// encodeTooltip.length && (encode.tooltip = encodeTooltip);

// encodeLabel.length && (encode.label = encodeLabel);

// User can set null in dimensions.

// We dont auto specify name, othewise a given name may

// cause it be refered unexpectedly.

// Also consider number form like 2012.

// User may also specify displayName.

// displayName will always exists except user not

// specified or dim name is not specified or detected.

// (A auto generated dim name will not be used as

// displayName).

// dimIndex may be overflow source data.

// Experience value.

// When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine

// always exists in source.

// Consider usage convenience, '1', '2' will be treated as "number".

// `isFinit('')` get `true`.

/**
 * ECharts global model
 *
 * @module {echarts/model/Global}
 */

/**
 * Caution: If the mechanism should be changed some day, these cases
 * should be considered:
 *
 * (1) In `merge option` mode, if using the same option to call `setOption`
 * many times, the result should be the same (try our best to ensure that).
 * (2) In `merge option` mode, if a component has no id/name specified, it
 * will be merged by index, and the result sequence of the components is
 * consistent to the original sequence.
 * (3) `reset` feature (in toolbox). Find detailed info in comments about
 * `mergeOption` in module:echarts/model/OptionManager.
 */

// Mark as not initialized.

/**
         * @type {module:echarts/model/Model}
         * @private
         */

/**
         * @type {module:echarts/model/OptionManager}
         */

/**
     * @param {string} type null/undefined: reset all.
     *                      'recreate': force recreate all.
     *                      'timeline': only reset timeline option
     *                      'media': only reset media query option
     * @return {boolean} Whether option changed.
     */

// Using OPTION_INNER_KEY to mark that this option can not be used outside,

// i.e. `chart.setOption(chart.getModel().option);` is forbiden.

/**
     * Init with series: [], in case of calling findSeries method
     * before series initialized.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @private
     */

/**
     * Mapping between filtered series list and raw series list.
     * key: filtered series indices, value: raw series indices.
     * @type {Array.<nubmer>}
     * @private
     */

// NOT use `colorLayer` in theme if option has `color`

// 如果有 component model 则把具体的 merge 逻辑交给该 model 处理

// TODO Needs clone when merging to the unexisted property

/**
 * @inner
 * @param {Array.<string>|string} types model types
 * @return {Object} key: {string} type, value: {Array.<Object>} models
 */

/**
 * MUST be called before mergeOption of all series.
 * @param {module:echarts/model/Global} ecModel
 */

// `datasetMap` is used to make default encode.

// If no component class, merge directly.

// For example: color, animaiton options, etc.

// globalSettingTask.dirty();

// Set mainType and complete subType.

// tooltip, markline, markpoint may always has no subType

// Backup series for filtering.

// Consider where is no new option and should be merged using {},

// see removeEdgeAndAdd in topologicalTravel and

// ComponentModel.getAllClassMainTypes.

// componentModel.settingTask && componentModel.settingTask.dirty();

// PENDING Global as parent ?

// Call optionUpdated after init.

// newCptOption has been used as componentModel.option

// and may be merged with theme and default, so pass null

// to avoid confusion.

/**
     * Get option for output (cloned option and inner info removed)
     * @public
     * @return {Object}
     */

// Remove options with inner id.

/**
     * @return {module:echarts/model/Model}
     */

/**
     * @param {string} mainType
     * @param {number} [idx=0]
     * @return {module:echarts/model/Component}
     */

/**
     * If none of index and id and name used, return all components with mainType.
     * @param {Object} condition
     * @param {string} condition.mainType
     * @param {string} [condition.subType] If ignore, only query by mainType
     * @param {number|Array.<number>} [condition.index] Either input index or id or name.
     * @param {string|Array.<string>} [condition.id] Either input index or id or name.
     * @param {string|Array.<string>} [condition.name] Either input index or id or name.
     * @return {Array.<module:echarts/model/Component>}
     */

// Return all components with mainType

/**
     * The interface is different from queryComponents,
     * which is convenient for inner usage.
     *
     * @usage
     * var result = findComponents(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series'},
     *     function (model, index) {...}
     * );
     * // result like [component0, componnet1, ...]
     *
     * @param {Object} condition
     * @param {string} condition.mainType Mandatory.
     * @param {string} [condition.subType] Optional.
     * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
     *        where xxx is mainType.
     *        If query attribute is null/undefined or has no index/id/name,
     *        do not filtering by query conditions, which is convenient for
     *        no-payload situations or when target of action is global.
     * @param {Function} [condition.filter] parameter: component, return boolean.
     * @return {Array.<module:echarts/model/Component>}
     */

// subType will be filtered finally.

/**
     * @usage
     * eachComponent('legend', function (legendModel, index) {
     *     ...
     * });
     * eachComponent(function (componentType, model, index) {
     *     // componentType does not include subType
     *     // (componentType is 'xxx' but not 'xxx.aa')
     * });
     * eachComponent(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
     *     function (model, index) {...}
     * );
     * eachComponent(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
     *     function (model, index) {...}
     * );
     *
     * @param {string|Object=} mainType When mainType is object, the definition
     *                                  is the same as the method 'findComponents'.
     * @param {Function} cb
     * @param {*} context
     */

/**
     * @param {string} name
     * @return {Array.<module:echarts/model/Series>}
     */

/**
     * @param {number} seriesIndex
     * @return {module:echarts/model/Series}
     */

/**
     * Get series list before filtered by type.
     * FIXME: rename to getRawSeriesByType?
     *
     * @param {string} subType
     * @return {Array.<module:echarts/model/Series>}
     */

/**
     * @return {Array.<module:echarts/model/Series>}
     */

/**
     * After filtering, series may be different
     * frome raw series.
     *
     * @param {Function} cb
     * @param {*} context
     */

/**
     * Iterate raw series before filtered.
     *
     * @param {Function} cb
     * @param {*} context
     */

/**
     * After filtering, series may be different.
     * frome raw series.
     *
     * @parma {string} subType
     * @param {Function} cb
     * @param {*} context
     */

/**
     * Iterate raw series before filtered of given type.
     *
     * @parma {string} subType
     * @param {Function} cb
     * @param {*} context
     */

/**
     * @param {module:echarts/model/Series} seriesModel
     */

/**
     * @return {Array.<number>}
     */

/**
     * @param {Function} cb
     * @param {*} context
     */

/**
 * @alias module:echarts/model/Global
 *
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {Object} theme
 */

// Using hasOwnProperty for restrict. Consider

// subType is undefined in user payload.

// Components that use _seriesIndices should depends on series component,

// which make sure that their initialization is after series.

// And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

/**
 * ECharts option manager
 *
 * @module {echarts/model/OptionManager}
 */

/**
 * TERM EXPLANATIONS:
 *
 * [option]:
 *
 *     An object that contains definitions of components. For example:
 *     var option = {
 *         title: {...},
 *         legend: {...},
 *         visualMap: {...},
 *         series: [
 *             {data: [...]},
 *             {data: [...]},
 *             ...
 *         ]
 *     };
 *
 * [rawOption]:
 *
 *     An object input to echarts.setOption. 'rawOption' may be an
 *     'option', or may be an object contains multi-options. For example:
 *     var option = {
 *         baseOption: {
 *             title: {...},
 *             legend: {...},
 *             series: [
 *                 {data: [...]},
 *                 {data: [...]},
 *                 ...
 *             ]
 *         },
 *         timeline: {...},
 *         options: [
 *             {title: {...}, series: {data: [...]}},
 *             {title: {...}, series: {data: [...]}},
 *             ...
 *         ],
 *         media: [
 *             {
 *                 query: {maxWidth: 320},
 *                 option: {series: {x: 20}, visualMap: {show: false}}
 *             },
 *             {
 *                 query: {minWidth: 320, maxWidth: 720},
 *                 option: {series: {x: 500}, visualMap: {show: true}}
 *             },
 *             {
 *                 option: {series: {x: 1200}, visualMap: {show: true}}
 *             }
 *         ]
 *     };
 *
 * @alias module:echarts/model/OptionManager
 * @param {module:echarts/ExtensionAPI} api
 */

/**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */

/**
     * @private
     * @type {Array.<number>}
     */

/**
     * @private
     * @type {Object}
     */

/**
     * -1, means default.
     * empty means no media.
     * @private
     * @type {Array.<number>}
     */

// timeline.notMerge is not supported in ec3. Firstly there is rearly

// case that notMerge is needed. Secondly supporting 'notMerge' requires

// rawOption cloned and backuped when timeline changed, which does no

// good to performance. What's more, that both timeline and setOption

// method supply 'notMerge' brings complex and some problems.

// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);

// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);

/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */

/**
     * @public
     * @param {Object} rawOption Raw option.
     * @param {module:echarts/model/Global} ecModel
     * @param {Array.<Function>} optionPreprocessorFuncs
     * @return {Object} Init option
     */

// That set dat primitive is dangerous if user reuse the data when setOption again.

// Caution: some series modify option data, if do not clone,

// it should ensure that the repeat modify correctly

// (create a new object when modify itself).

// 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

// For timeline

// For media query

// Use the first media default.

// For normal option

// Set timelineOpt to baseOption in ec3,

// which is convenient for merge option.

// Preprocess.

// For setOption at second time (using merge mode);

// Only baseOption can be merged.

/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 */

// For simplicity, timeline options and media options do not support merge,

// that is, if you `setOption` twice and both has timeline options, the latter

// timeline opitons will not be merged to the formers, but just substitude them.

/**
     * @param {boolean} isRecreate
     * @return {Object}
     */

// 如果没有reset功能则不clone。

/**
     * @param {module:echarts/model/Global} ecModel
     * @return {Object}
     */

// getTimelineOption can only be called after ecModel inited,

// so we can get currentIndex from timelineModel.

/**
     * @param {module:echarts/model/Global} ecModel
     * @return {Array.<Object>}
     */

// No media defined.

// Multi media may be applied, the latter defined media has higher priority.

// 是否mediaDefault应该强制用户设置，否则可能修改不能回归。

// indices is always order by asc and has only finite number.

// Otherwise return nothing.

// Timeline controlStyle has other properties besides normal and emphasis

// treemap

// graph

// Check whether is not object (string\null\undefined ...)

// Break with ec3: if `setOption` again, there may be no `type` in option,

// then the backward compat based on option type will not be performed.

// mark point data

// mark line data

// Series

// sunburst starts from ec4, so it does not need to compat levels.

// radar.name.textStyle

// Make sure series array for model initialization.

// Compatitable with 2.0

// dataRange has changed to visualMap

// Consider `connectNulls` of line area, if value is NaN, stackedOver

// should also be NaN, to draw a appropriate belt area.

// If stackOver is NaN, chart view will render point on value start.

// Has been optimized by inverted indices on `stackedByDimension`.

// Considering positive stack, negative stack and empty data

// Positive stack

// Update for consequent calculation

// ??? refactor? check the outer usage of data provider.

// merge with defaultDimValueGetter?

/**
 * If normal array used, mutable chunk size is supported.
 * If typed array used, chunk size must be fixed.
 */

// Typed array. TODO IE10+?

// If data is pure without style configuration

// If data is persistent and will not be released after use.

// ???! FIXME legacy data provider do not has method getSource

// Clean self if data is already used.

// In some case (markpoint in geo (geo-map.html)), dataItem

// is {coord: [...]}

// Performance sensitive, do not use modelUtil.getDataItemValue.

// If dataItem is an plain object with no value field, the var `value`

// will be assigned with the object, but it will be tread correctly

// in the `convertDataValue`.

// If any dataItem is like { value: 10 }

// // markLine data can be array

// && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));

/**
 * This helper method convert value in data.
 * @param {string|number|Date} value
 * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
 *        If "dimInfo.ordinalParseAndSave", ordinal value can be parsed.
 */

// Performance sensitive.

// dimType defaults 'number'.

// If dimType is not ordinal and value is null or undefined or NaN or '-',

// parse to NaN.

// If given value is a category string

// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,

// Consider persistent.

// Caution: why use raw value to display on label or tooltip?

// A reason is to avoid format. For example time value we do not know

// how to format is expected. More over, if stack is used, calculated

// value may be 0.91000000001, which have brings trouble to display.

// TODO: consider how to treat null/undefined/NaN when display?

/**
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @param {string|number} [dim] dimName or dimIndex
 * @return {Array.<number>|string|number} can be null/undefined.
 */

// Consider data may be not persistent.

/**
 * Compatible with some cases (in pie, map) like:
 * data: [{name: 'xx', value: 5, selected: true}, ...]
 * where only sourceFormat is 'original' and 'objectRows' supported.
 *
 * ??? TODO
 * Supported detail options in data item when using 'arrayRows'.
 *
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @param {string} attr like 'selected'
 */

/**
     * Get params for formatter
     * @param {number} dataIndex
     * @param {string} [dataType]
     * @return {Object}
     */

// Param name list for mapping `a`, `b`, `c`, `d`, `e`

/**
     * Format label
     * @param {number} dataIndex
     * @param {string} [status='normal'] 'normal' or 'emphasis'
     * @param {string} [dataType]
     * @param {number} [dimIndex]
     * @param {string} [labelProp='label']
     * @return {string} If not formatter, return null/undefined
     */

/**
     * Get raw value in option
     * @param {number} idx
     * @param {string} [dataType]
     * @return {Array|number|string}
     */

/**
     * Should be implemented.
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     * @return {string} tooltip string
     */

// Empty function

// PENDING A little ugly

/**
 * @param {Object} define
 * @return See the return of `createTask`.
 */

/**
 * @constructor
 * @param {Object} define
 * @param {Function} define.reset Custom reset
 * @param {Function} [define.plan] Returns 'reset' indicate reset immediately.
 * @param {Function} [define.count] count is used to determin data task.
 * @param {Function} [define.onDirty] count is used to determin data task.
 */

// Context must be specified implicitly, to

// avoid miss update context when model changed.

/**
 * @param {Object} performArgs
 * @param {number} [performArgs.step] Specified step.
 * @param {number} [performArgs.skip] Skip customer perform call.
 * @param {number} [performArgs.modBy] Sampling window size.
 * @param {number} [performArgs.modDataCount] Sampling count.
 */

// TODO some refactor.

// Pull data. Must pull data each time, because context.data

// may be updated by Series.setData.

// Support sharding by mod, which changes the render sequence and makes the rendered graphic

// elements uniformed distributed when progress, especially when moving or zooming.

// To simplify no progress checking, array must has item.

/**
 * @return {boolean}
 */

// Note: Stubs, that its host overall task let it has progress, has progress.

// If no progress, pass index from upstream to downstream each time plan called.

// If no `outputDueEnd`, assume that output data and

// input data is the same, so use `dueIndex` as `outputDueEnd`.

// ??? Can not rollback.

// (1) Some overall task has no progress.

// (2) Stubs, that its host overall task do not let it has progress, has no progress.

// This should always be performed so it can be passed to downstream.

/**
 * @param {Object} downTask The downstream task.
 * @return {Object} The downstream task.
 */

// If already downstream, do not dirty downTask.

// This only happend in dataTask, dataZoom, map, currently.

// where dataZoom do not set end each time, but only set

// when reset. So we should record the setted end, in case

// that the stub of dataZoom perform again and earse the

// setted end by upstream.

///////////////////////////////////////////////////////////

// For stream debug (Should be commented out after used!)

// Usage: printTask(this, 'begin');

// Usage: printTask(this, null, {someExtraProp});

// function printTask(task, prefix, extra) {

//     window.ecTaskUID == null && (window.ecTaskUID = 0);

//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);

//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);

//     var props = [];

//     if (task.__pipeline) {

//         var val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;

//         props.push({text: 'idx', value: val});

//     } else {

//         var stubCount = 0;

//         task.agentStubMap.each(() => stubCount++);

//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});

//     props.push({text: 'uid', value: task.uidDebug});

//         props.push({text: 'pid', value: task.__pipeline.id});

//         task.agent && props.push(

//             {text: 'stubFor', value: task.agent.uidDebug}

//         );

//     props.push(

//         {text: 'dirty', value: task._dirty},

//         {text: 'dueIndex', value: task._dueIndex},

//         {text: 'dueEnd', value: task._dueEnd},

//         {text: 'outputDueEnd', value: task._outputDueEnd}

//     if (extra) {

//         Object.keys(extra).forEach(key => {

//             props.push({text: key, value: extra[key]});

//     var args = ['color: blue'];

//     var msg = `%c[${prefix || 'T'}] %c` + props.map(item => (

//         args.push('color: black', 'color: red'),

//         `${item.text}: %c${item.value}`

//     )).join('%c, ');

//     console.log.apply(console, [msg].concat(args));

//     // console.log(this);

// coodinateSystem will be injected in the echarts/CoordinateSystem

/**
     * Data provided for legend
     * @type {Function}
     */

/**
     * Access path of color for visual
     */

/**
         * @type {number}
         * @readOnly
         */

/**
         * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
         * @private
         */

// If we reverse the order (make data firstly, and then make

// dataBeforeProcessed by cloneShallow), cloneShallow will

// cause data.graph.data !== data when using

// module:echarts/data/Graph or module:echarts/data/Tree.

// See module:echarts/data/helper/linkList

// Theoretically, it is unreasonable to call `seriesModel.getData()` in the model

// init or merge stage, because the data can be restored. So we do not `restoreData`

// and `setData` here, which forbids calling `seriesModel.getData()` in this stage.

// Call `seriesModel.getRawData()` instead.

// this.restoreData();

/**
     * Util for merge default and theme to option
     * @param  {Object} option
     * @param  {module:echarts/model/Global} ecModel
     */

// Default label emphasis `show`

// this.settingTask.dirty();

// Default data label emphasis `show`

// FIXME Tree structure data ?

// FIXME Performance ?

/**
     * Init a data structure from data related option in series
     * Must be overwritten
     */

/**
     * Append data to list
     * @param {Object} params
     * @param {Array|TypedArray} params.data
     */

/**
     * Consider some method like `filter`, `map` need make new data,
     * We should make sure that `seriesModel.getData()` get correct
     * data in the stream procedure. So we fetch data from upstream
     * each time `task.perform` called.
     * @param {string} [dataType]
     * @return {module:echarts/data/List}
     */

// When series is not alive (that may happen when click toolbox

// restore or setOption with not merge mode), series data may

// be still need to judge animation or something when graphic

// elements want to know whether fade out.

/**
     * @param {module:echarts/data/List} data
     */

// Consider case: filter, data sample.

// Caution: setData should update context.data,

// Because getData may be called multiply in a

// single stage and expect to get the data just

// set. (For example, AxisProxy, x y both call

// getData and setDate sequentially).

// So the context.data should be fetched from

// upstream each time when a stage starts to be

// performed.

/**
     * @see {module:echarts/data/helper/sourceHelper#getSource}
     * @return {module:echarts/data/Source} source
     */

/**
 * [Scenarios]:
 * (1) Provide source data directly:
 *     series: {
 *         encode: {...},
 *         dimensions: [...]
 *         seriesLayoutBy: 'row',
 *         data: [[...]]
 *     }
 * (2) Refer to datasetModel.
 *     series: [{
 *         encode: {...}
 *         // Ignore datasetIndex means `datasetIndex: 0`
 *         // and the dimensions defination in dataset is used
 *     }, {
 *         encode: {...},
 *         seriesLayoutBy: 'column',
 *         datasetIndex: 1
 *     }]
 *
 * Get data from series itself or datset.
 * @return {module:echarts/data/Source} source
 */

/**
     * Get data before processed
     * @return {module:echarts/data/List}
     */

/**
     * Get base axis if has coordinate system and has axis.
     * By default use coordSys.getBaseAxis();
     * Can be overrided for some chart.
     * @return {type} description
     */

/**
     * Default tooltip formatter
     *
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     * @param {string} [renderMode='html'] valid values: 'html' and 'richText'.
     *                                     'html' is used for rendering tooltip in extra DOM form, and the result
     *                                     string is used as DOM HTML content.
     *                                     'richText' is used for rendering tooltip in rich text form, for those where
     *                                     DOM operation is not supported.
     * @return {Object} formatted tooltip with `html` and `markers`
     */

// return encodeHTML(addCommas(val));

// Complicated rule for pretty tooltip.

// ??? TODO refactor these logic.

// check: category-no-encode-has-axis-data in dataset.html

// If `dimInfo.tooltip` is not set, show tooltip.

// FIXME should not format time for raw data?

/**
     * @return {boolean}
     */

/**
     * Use `data.mapDimension(coordDim, true)` instead.
     * @deprecated
     */

/**
     * Get progressive rendering count each step
     * @return {number}
     */

/**
     * Get data indices for show tooltip content. See tooltip.
     * @abstract
     * @param {Array.<string>|string} dim
     * @param {Array.<number>} value
     * @param {module:echarts/coord/single/SingleAxis} baseAxis
     * @return {Object} {dataIndices, nestestValue}.
     */

/**
     * See tooltip.
     * @abstract
     * @param {number} dataIndex
     * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
     */

/**
     * @see {module:echarts/stream/Scheduler}
     */

/**
     * Convinient for override in extended class.
     * @protected
     * @type {Function}
     */

/**
     * @public
     * @readOnly
     * @type {Object}
     */

/**
 * MUST be called after `prepareSource` called
 * Here we need to make auto series, especially for auto legend. But we
 * do not modify series.name in option to avoid side effects.
 */

// User specified name has higher priority, otherwise it may cause

// series can not be queried unexpectedly.

// Avoid repead cloneShallow when data just created in reset.

// TODO refactor

// Consider case: filter, selectRange

// When pipline finished, the currrentTask keep the last

// task (renderTask).

/**
     * @type {module:zrender/container/Group}
     * @readOnly
     */

/**
     * @param {string} eventType
     * @param {Object} query
     * @param {module:zrender/Element} targetEl
     * @param {Object} packedEvent
     * @return {boolen} Pass only when return `true`.
     */

// Do nothing;

// Enable Component.extend.

// Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

/**
 * @return {string} If large mode changed, return string 'reset';
 */

/**
     * Init the chart.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */

/**
     * Render the chart.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */

/**
     * Highlight series or specified data item.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */

/**
     * Downplay series or specified data item.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */

/**
     * Remove self.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */

/**
     * Dispose self.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */

/**
     * Rendering preparation in progressive mode.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */

/**
     * Render in progressive mode.
     * @param  {Object} params See taskParams in `stream/task.js`
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */

/**
     * Update transform directly.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     * @return {Object} {update: true}
     */

/**
     * The view contains the given point.
     * @interface
     * @param {Array.<number>} point
     * @return {boolean}
     */

// containPoint: function () {}

/**
 * Set state of single element
 * @param  {module:zrender/Element} el
 * @param  {string} state
 */

/**
 * @param  {module:echarts/data/List} data
 * @param  {Object} payload
 * @param  {string} state 'normal'|'emphasis'
 */

// Enable Chart.extend.

// Put view.render in `progress` to support appendData. But in this case

// view.render should not be called in reset, otherwise it will be called

// twise. Use `forceFirstProgress` to make sure that view.render is called

// in any cases.

/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */

// Here we should make sure that: the `exec` SHOULD NOT be called later

// than a new call of `cb`, that is, preserving the command order. Consider

// calculating "scale rate" when roaming as an example. When a call of `cb`

// happens, either the `exec` is called dierectly, or the call is delayed.

// But the delayed call should never be later than next call of `cb`. Under

// this assurance, we can simply update view state each time `dispatchAction`

// triggered by user roaming, but not need to add extra code to avoid the

// state being "rolled-back".

/**
     * Clear throttle.
     * @public
     */

/**
     * Enable debounce once.
     */

/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 * @param {number} [rate]
 * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
 * @return {Function} throttled function.
 */

/**
 * Clear throttle. Example see throttle.createOrUpdate.
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 */

// TODO series count changed.

// Only visible series has each data be visual encoded

// Default color

// FIXME Set color function or use the platte color

// itemStyle in each data item

// Show part of data

/**
 * @module echarts/stream/Scheduler
 */

/**
 * @constructor
 */

// Fix current processors in case that in some rear cases that

// processors might be registered after echarts instance created.

// Register processors incrementally for a echarts instance is

// not supported by this stream architecture.

/**
     * @private
     * @type {
     *     [handlerUID: string]: {
     *         seriesTaskMap?: {
     *             [seriesUID: string]: Task
     *         },
     *         overallTask?: Task
     *     }
     * }
     */

/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} payload
 */

// Execute stubs firstly, which may set the overall task dirty,

// then execute the overall task. And stub will call seriesModel.setData,

// which ensures that in the overallTask seriesModel.getData() will not

// return incorrect data.

// TODO: Only restroe needed series and components, but not all components.

// Currently `restoreData` of all of the series and component will be called.

// But some independent components like `title`, `legend`, `graphic`, `toolbox`,

// `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,

// and some components like coordinate system, axes, dataZoom, visualMap only

// need their target series refresh.

// (1) If we are implementing this feature some day, we should consider these cases:

// if a data processor depends on a component (e.g., dataZoomProcessor depends

// on the settings of `dataZoom`), it should be re-performed if the component

// is modified by `setOption`.

// (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,

// it should be re-performed when the result array of `getTargetSeries` changed.

// We use `dependencies` to cover these issues.

// (3) How to update target series when coordinate system related components modified.

// TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,

// and this case all of the tasks will be set as dirty.

// Theoretically an overall task not only depends on each of its target series, but also

// depends on all of the series.

// The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks

// dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure

// that the overall task is set as dirty and to be performed, otherwise it probably cause

// state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it

// probably cause state chaos (consider `dataZoomProcessor`).

// If seriesModel provided, incremental threshold is check by series data.

// For overall task

/**
 * Current, progressive rendering starts from visual and layout.
 * Always detect render mode in the same stage, avoiding that incorrect
 * detection caused by data filtering.
 * Caution:
 * `updateStreamModes` use `seriesModel.getData()`.
 */

// If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,

// to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,

// it works but it may cause other irrelevant charts blocked.

// Init tasks for each seriesModel only once.

// Reuse original task instance.

// Clear unused series tasks.

// Reuse orignal stubs.

// An overall task with seriesType detected or has `getTargetSeries`, we add

// stub in each pipelines, it will set the overall task dirty when the pipeline

// progress. Moreover, to avoid call the overall task each frame (too frequent),

// we set the pipeline block.

// When the result of `getTargetSeries` changed, the overallTask

// should be set as dirty and re-performed.

// Clear unused stubs.

// If we do not use `block` here, it should be considered when to update modes.

// opt

// opt.visualType: 'visual' or 'layout'

// opt.setDirty

// Progress to the end for dataInit and dataRestore.

// Travel pipelines, check block.

/**
 * Only some legacy stage handlers (usually in echarts extensions) are pure function.
 * To ensure that they can work normally, they should work in block mode, that is,
 * they should not be started util the previous tasks finished. So they cause the
 * progressive rendering disabled. We try to detect the series type, to narrow down
 * the block range to only the series type they concern, but not all series.
 */

// Assume there is no async when calling `eachSeriesByType`.

// Do not use hasOwnProperty

/**
 * This module is imported by echarts directly.
 *
 * Notice:
 * Always keep this file exists for backward compatibility.
 * Because before 4.1.0, dataset is an optional component,
 * some users may import this module manually.
 */

// 'row', 'column'

// null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"

// FIXME Whether tolerate null in top level array?

/**
 * 椭圆形状
 * @module zrender/graphic/shape/Ellipse
 */

// 垂直控制点偏移量

// 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线

// import RadialGradient from '../graphic/RadialGradient';

// import Pattern from '../graphic/Pattern';

// import * as vector from '../core/vector';

// Most of the values can be separated by comma and/or white space.

/**
 * For big svg string, this method might be time consuming.
 *
 * @param {string} svg xml string
 * @return {Object} xml root.
 */

// Document node. If using $.get, doc node may be input.

// nodeName of <!DOCTYPE svg> is also 'svg'.

// console.log(xmlNode.getAttribute('transform'));

// console.log(rect.transform);

// new offset x

// new offset y

// TODO svg fill rule

// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule

// path.style.globalCompositeOperation = 'xor';

// percentage

// TODO Shadow

// Value may contain space.

/**
 * @param {Array.<number>} viewBoxRect
 * @param {number} width
 * @param {number} height
 * @return {Object} {scale, position}
 */

// enable stroke

// if (str === 'none') {

//     return;

/**
 * @param {string|XMLElement} xml
 * @param {Object} [opt]
 * @param {number} [opt.width] Default width if svg width not specified or is a percent value.
 * @param {number} [opt.height] Default height if svg height not specified or is a percent value.
 * @param {boolean} [opt.ignoreViewBox]
 * @param {boolean} [opt.ignoreRootClip]
 * @return {Object} result:
 * {
 *     root: Group, The root of the the result tree of zrender shapes,
 *     width: number, the viewport width of the SVG,
 *     height: number, the viewport height of the SVG,
 *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,
 *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.
 * }
 */

// Backward compatibility.

// Only perform parse to XML object here, which might be time

// consiming for large SVG.

// Although convert XML to zrender element is also time consiming,

// if we do it here, the clone of zrender elements has to be

// required. So we do it once for each geo instance, util real

// performance issues call for optimizing it.

// For minimize the code size of common echarts package,

// do not put too much logic in this module.

// Event name is all lowercase

/**
 * @module echarts~MessageCenter
 */

/**
 * @module echarts~ECharts
 */

// Get theme by name

/**
     * Group id
     * @type {string}
     */

/**
     * @type {HTMLElement}
     * @private
     */

/**
     * @type {module:zrender/ZRender}
     * @private
     */

/**
     * Expect 60 pfs.
     * @type {Function}
     * @private
     */

/**
     * @type {Object}
     * @private
     */

/**
     * @type {Array.<module:echarts/view/Chart>}
     * @private
     */

/**
     * @type {Object.<string, module:echarts/view/Chart>}
     * @private
     */

/**
     * @type {Array.<module:echarts/view/Component>}
     * @private
     */

/**
     * @type {Object.<string, module:echarts/view/Component>}
     * @private
     */

/**
     * @type {module:echarts/CoordinateSystem}
     * @private
     */

/**
     * @type {module:echarts/ExtensionAPI}
     * @private
     */

// Inject methods

/**
 * @class
 * Usage of query:
 * `chart.on('click', query, handler);`
 * The `query` can be:
 * + The component type query string, only `mainType` or `mainType.subType`,
 *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
 * + The component query object, like:
 *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
 *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
 * + The data query object, like:
 *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
 * + The other query object (cmponent customized query), like:
 *   `{element: 'some'}` (only available in custom series).
 *
 * Caveat: If a prop in the `query` object is `null/undefined`, it is the
 * same as there is no such prop in the `query` object.
 */

// Sort on demand

/**
     * @type {module:echarts/stream/Scheduler}
     */

/**
     * @type {module:echarts~MessageCenter}
     * @private
     */

// Init mouse events

// In case some people write `window.onresize = chart.resize`

// Can't dispatch action during rendering procedure

/**
 * Event `rendered` is triggered when zr
 * rendered. It is useful for realtime
 * snapshot (reflect animation).
 *
 * Event `finished` is triggered when:
 * (1) zrender rendering finished.
 * (2) initial animation finished.
 * (3) progressive rendering finished.
 * (4) no pending action.
 * (5) no delayed setOption needs to be processed.
 */

// The `finished` event should not be triggered repeatly,

// so it should only be triggered when rendering indeed happend

// in zrender. (Consider the case that dipatchAction is keep

// triggering when mouse move).

// Although zr is dirty if initial animation is not finished

// and this checking is called on frame, we also check

// animation finished for robustness.

/**
 * @param {Object} params
 * @param {number} params.seriesIndex
 * @param {Array|TypedArray} params.data
 */

// ECharts instance can be used as value.

/**
 * Is the specified coordinate systems or components contain the given pixel point.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {boolean} result
 */

// Lazy update

// Avoid do both lazy update and progress in one frame.

// Stream progress.

// Currently dataProcessorFuncs do not check threshold.

// Do not update coordinate system here. Because that coord system update in

// each frame is not a good user experience. So we follow the rule that

// the extent of the coordinate system is determin in the first frame (the

// frame is executed immedietely after task reset.

// this._coordSysMgr.update(ecModel, api);

// console.log('--- ec frame visual ---', remainTime);

// Call flush explicitly for trigger finished event.

// Else, zr flushing be ensue within the same frame,

// because zr flushing is after onframe event.

/**
 * @return {HTMLElement}
 */

/**
 * @return {module:zrender~ZRender}
 */

/**
 * Usage:
 * chart.setOption(option, notMerge, lazyUpdate);
 * chart.setOption(option, {
 *     notMerge: ...,
 *     lazyUpdate: ...,
 *     silent: ...
 * });
 *
 * @param {Object} option
 * @param {Object|boolean} [opts] opts or notMerge.
 * @param {boolean} [opts.notMerge=false]
 * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
 */

// Ensure zr refresh sychronously, and then pixel in canvas can be

// fetched after `setOption`.

/**
 * @DEPRECATED
 */

/**
 * @return {module:echarts/model/Global}
 */

/**
 * @return {Object}
 */

/**
 * Get canvas which has all thing rendered
 * @param {Object} opts
 * @param {string} [opts.backgroundColor]
 * @return {string}
 */

// var list = zr.storage.getDisplayList();

// Stop animations

// Never works before in init animation, so remove it.

// zrUtil.each(list, function (el) {

//     el.stopAnimation(true);

// });

/**
 * Get svg data url
 * @return {string}
 */

/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 * @param {string} [opts.excludeComponents]
 */

/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 */

/**
 * Convert from logical coordinate system to pixel coordinate system.
 * See CoordinateSystem#convertToPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId, geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */

/**
 * Convert from pixel coordinate system to logical coordinate system.
 * See CoordinateSystem#convertFromPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */

/**
 * Get visual from series or data.
 * @param {string|Object} finder
 *        If string, e.g., 'series', means {seriesIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            dataIndex / dataIndexInside
 *        }
 *        If dataIndex is not specified, series visual will be fetched,
 *        but not data item visual.
 *        If all of seriesIndex, seriesId, seriesName are not specified,
 *        visual will be fetched from first series.
 * @param {string} visualType 'color', 'symbol', 'symbolSize'
 */

/**
 * Get view of corresponding component model
 * @param  {module:echarts/model/Component} componentModel
 * @return {module:echarts/view/Component}
 */

/**
 * Get view of corresponding series model
 * @param  {module:echarts/model/Series} seriesModel
 * @return {module:echarts/view/Chart}
 */

/**
     * @param {Object} payload
     * @private
     */

// console.profile && console.profile('update');

// update before setOption

// Save total ecModel here for undo/redo (after restoring data and before processing data).

// Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.

// Create new coordinate system each update

// In LineView may save the old coordinate system and use it to get the orignal point

// Current stream render is not supported in data process. So we can update

// stream modes after data processing, where the filtered data is used to

// deteming whether use progressive rendering.

// We update stream modes before coordinate system updated, then the modes info

// can be fetched when coord sys updating (consider the barGrid extent fix). But

// the drawback is the full coord info can not be fetched. Fortunately this full

// coord is not requied in stream mode updater currently.

// Set background

// In IE8

// ChartView.markUpdateMethod(payload, 'updateTransform');

// Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

// this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

// Currently, not call render of components. Geo render cost a lot.

// renderComponents(ecIns, ecModel, api, payload, componentDirtyList);

// var ecModel = this._model;

// // update before setOption

// if (!ecModel) {

// ChartView.markUpdateMethod(payload, 'updateVisual');

// clearColorPalette(ecModel);

// // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

// this._scheduler.performVisualTasks(ecModel, payload, {visualType: 'visual', setDirty: true});

// render(this, this._model, this._api, payload);

// performPostUpdateFuncs(ecModel, this._api);

// ChartView.markUpdateMethod(payload, 'updateLayout');

// // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

// this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});

/**
 * @private
 */

// broadcast

// subType may be '' by parseClassType;

// If dispatchAction before setOption, do nothing.

// Chart will not be update directly here, except set dirty.

// But there is no such scenario now.

/**
 * Resize the chart
 * @param {Object} opts
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 * @param {boolean} [opts.silent=false]
 */

/**
 * Show loading effect
 * @param  {string} [name='default']
 * @param  {Object} [cfg]
 */

// Batch action

// Action can specify the event by return it.

// Convert type to eventType

// Emit event outside

// light update does not perform data process, layout and visual.

// method, payload, mainType, subType

// Still dirty

// FIXME Pass payload ?

// Follow the rule of action batch

/**
 * Prepare view instances of charts and components
 * @param  {module:echarts/model/Global} ecModel
 * @private
 */

// Consider: id same and type changed.

// /**

//  * Encode visual infomation from data after data processing

//  *

//  * @param {module:echarts/model/Global} ecModel

//  * @param {object} layout

//  * @param {boolean} [layoutFilter] `true`: only layout,

//  *                                 `false`: only not layout,

//  *                                 `null`/`undefined`: all.

//  * @param {string} taskBaseTag

//  * @private

//  */

// function startVisualEncoding(ecIns, ecModel, api, payload, layoutFilter) {

//     each(visualFuncs, function (visual, index) {

//         var isLayout = visual.isLayout;

//         if (layoutFilter == null

//             || (layoutFilter === false && !isLayout)

//             || (layoutFilter === true && isLayout)

//         ) {

//             visual.func(ecModel, api, payload);

//     });

/**
 * Render each chart and component
 * @private
 */

// Remove groups of unrendered charts

// Render all charts

/**
 * Update chart progressive and blend.
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */

// FIXME marker and other components

// Only set if blendMode is changed. In case element is incremental and don't wan't to rerender.

/**
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */

// If use hover layer

// Don't switch back.

// Add aria

// Resize loading effect

/**
 * Hide loading effect
 */

/**
 * @param {Object} eventObj
 * @return {Object}
 */

/**
 * @pubilc
 * @param {Object} payload
 * @param {string} [payload.type] Action type
 * @param {Object|boolean} [opt] If pass boolean, means opt.silent
 * @param {boolean} [opt.silent=false] Whether trigger events.
 * @param {boolean} [opt.flush=undefined]
 *                  true: Flush immediately, and then pixel in canvas can be fetched
 *                      immediately. Caution: it might affect performance.
 *                  false: Not not flush.
 *                  undefined: Auto decide whether perform flush.
 */

// May dispatchAction in rendering procedure

// In WeChat embeded browser, `requestAnimationFrame` and `setInterval`

// hang when sliding page (on touch event), which cause that zr does not

// refresh util user interaction finished, which is not expected.

// But `dispatchAction` may be called too frequently when pan on touch

// screen, which impacts performance if do not throttle them.

// Note: `appendData` does not support that update extent of coordinate

// system, util some scenario require that. In the expected usage of

// `appendData`, the initial extent of coordinate system should better

// be fixed by axis `min`/`max` setting or initial data, otherwise if

// the extent changed while `appendData`, the location of the painted

// graphic elements have to be changed, which make the usage of

// `appendData` meaningless.

/**
 * Register event
 * @method
 */

// Set z and zlevel

// These info required: targetEl, packedEvent, model, view

// no e.target when 'globalout'.

// If element has custom eventData of components

// Contract: if params prepared in mouse event,

// these properties must be specified:

//    componentType: string (component main type)

//    componentIndex: number

// Otherwise event query can not work.

// Special handling for historic reason: when trigger by

// markLine/markPoint/markArea, the componentType is

// 'markLine'/'markPoint'/'markArea', but we should better

// enable them to be queried by seriesIndex, since their

// option is set in each series.

// `event.componentType` and `event[componentTpype + 'Index']` must not

// be missed, otherwise there is no way to distinguish source component.

// See `dataFormat.getDataParams`.

// Consider that some component (like tooltip, brush, ...)

// register zr event handler, but user event handler might

// do anything, such as call `setOption` or `dispatchAction`,

// which probably update any of the content and probably

// cause problem if it is called previous other inner handlers.

/**
 * Clear
 */

/**
 * Dispose instance
 */

// Dispose after all views disposed

// `query` is `mainType` or `mainType.subType` of component.

// `.main` and `.sub` may be ''.

// `query` is an object, convert to {mainType, index, name, id}.

// `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,

// can not be used in `compomentModel.filterForExposedEvent`.

// Consider `dataIndex`.

// They should be assigned before each trigger call.

// For event like 'globalout'.

// Make sure the eventInfo wont be used in next trigger.

/**
 * @type {Object} key: actionType.
 * @inner
 */

/**
 * Map eventType to actionType
 * @type {Object}
 */

/**
 * @DEPRECATED
 * @return {string} groupId
 */

/**
 * @return {string} groupId
 */

/**
 * Dispose a chart instance
 * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
 */

/**
 * @param  {HTMLElement} dom
 * @return {echarts~ECharts}
 */

/**
 * @param {string} key
 * @return {echarts~ECharts}
 */

/**
 * Register theme
 */

/**
 * Register option preprocessor
 * @param {Function} preprocessorFunc
 */

/**
 * @param {number} [priority=1000]
 * @param {Object|Function} processor
 */

/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */

/**
 * Usage:
 * registerAction('someAction', 'someEvent', function () { ... });
 * registerAction('someAction', function () { ... });
 * registerAction(
 *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
 *     function () { ... }
 * );
 *
 * @param {(string|Object)} actionInfo
 * @param {string} actionInfo.type
 * @param {string} [actionInfo.event]
 * @param {string} [actionInfo.update]
 * @param {string} [eventName]
 * @param {Function} action
 */

// Validate action type and event name.

/**
 * @param {string} type
 * @param {*} CoordinateSystem
 */

/**
 * Layout is a special stage of visual encoding
 * Most visual encoding like color are common for different chart
 * But each chart has it's own layout algorithm
 *
 * @param {number} [priority=1000]
 * @param {Function} layoutTask
 */

/**
 * @param {number} [priority=3000]
 * @param {module:echarts/stream/Task} visualTask
 */

/**
 * @param {Object|Function} fn: {seriesType, createOnAllSeries, performRawSeries, reset}
 */

// Check duplicate

/**
 * @param {string} name
 */

/**
 * @param {Object} opts
 * @param {string} [superClass]
 */

/*, superClass*/

// var Clazz = ComponentModel;

// if (superClass) {

//     var classType = parseClassType(superClass);

//     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);

// var Clazz = ComponentView;

//     Clazz = ComponentView.getClass(classType.main, classType.sub, true);

// var Clazz = SeriesModel;

//     superClass = 'series.' + superClass.replace('series.', '');

// var Clazz = ChartView;

//     superClass = superClass.replace('series.', '');

//     Clazz = ChartView.getClass(classType.main, true);

/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 * Be careful of using it in the browser.
 *
 * @param {Function} creator
 * @example
 *     var Canvas = require('canvas');
 *     var echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */

// Compatibal: when `stack` is set as '', do not stack.

// Used for calculate axis extent automatically.

// If stacked on axis that do not support data stack.

// Inject resize

// Default actions

// Default theme

/**
 * @param {Array} oldArr
 * @param {Array} newArr
 * @param {Function} oldKeyGetter
 * @param {Function} newKeyGetter
 * @param {Object} [context] Can be visited by this.context in callback.
 */

// Add prefix to avoid conflict with Object.prototype.

/**
     * Callback function when add a data
     */

/**
     * Callback function when update a data
     */

/**
     * Callback function when remove a data
     */

// Travel by inverted order to make sure order consistency

// when duplicate keys exists (consider newDataIndex.pop() below).

// For performance consideration, these code below do not look neat.

// idx can never be empty array here. see 'set null' logic below.

// idx can never be empty array here. see 'set null' logic above.

// function findTheLastDimMayLabel(data) {

//     // Get last value dim

//     var dimensions = data.dimensions.slice();

//     var valueType;

//     var valueDim;

//     while (dimensions.length && (

//         valueDim = dimensions.pop(),

//         valueType = data.getDimensionInfo(valueDim).type,

//         valueType === 'ordinal' || valueType === 'time'

//     )) {} // jshint ignore:line

//     return valueDim;

/* global Float64Array, Int32Array, Uint32Array, Uint16Array */

/**
 * List for data storage
 * @module echarts/data/List
 */

// Ordinal data type can be string or int

// The possible max value in this._indicies is always this._rawCount despite of filtering.

/**
 * @constructor
 * @alias module:echarts/data/List
 *
 * @param {Array.<string|Object>} dimensions
 *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
 *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
 *      Spetial fields: {
 *          ordinalMeta: <module:echarts/data/OrdinalMeta>
 *          createInvertedIndices: <boolean>
 *      }
 * @param {module:echarts/model/Model} hostModel
 */

// Use the original dimensions[i], where other flag props may exists.

/**
     * @readOnly
     * @type {Array.<string>}
     */

/**
     * Infomation of each data dimension, like data type.
     * @type {Object}
     */

/**
     * @type {module:echarts/model/Model}
     */

/**
     * Indices stores the indices of data subset after filtered.
     * This data subset will be used in chart.
     * @type {Array.<number>}
     * @readOnly
     */

/**
     * Data storage
     * @type {Object.<key, Array.<TypedArray|Array>>}
     * @private
     */

/**
     * @type {Array.<string>}
     */

/**
     * Models of data option is stored sparse for optimizing memory cost
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */

/**
     * Global visual properties after visual coding
     * @type {Object}
     * @private
     */

/**
     * Globel layout properties.
     * @type {Object}
     * @private
     */

/**
     * Item visual properties after visual coding
     * @type {Array.<Object>}
     * @private
     */

/**
     * Key: visual type, Value: boolean
     * @type {Object}
     * @readOnly
     */

/**
     * Item layout properties after layout
     * @type {Array.<Object>}
     * @private
     */

/**
     * Graphic elemnents
     * @type {Array.<module:zrender/Element>}
     * @private
     */

/**
     * Max size of each chunk.
     * @type {number}
     * @private
     */

/**
     * @type {number}
     * @private
     */

/**
     * @type {Array.<Array|Object>}
     * @private
     */

/**
     * Raw extent will not be cloned, but only transfered.
     * It will not be calculated util needed.
     * key: dim,
     * value: {end: number, extent: Array.<number>}
     * @type {Object}
     * @private
     */

/**
     * key: dim
     * value: extent
     * @type {Object}
     * @private
     */

/**
     * Cache summary info for fast visit. See "dimensionHelper".
     * @type {Object}
     * @private
     */

// Use the last coord dim (and label friendly) as default label,

// because when dataset is used, it is hard to guess which dimension

// can be value dimension. If both show x, y on label is not look good,

// and conventionally y axis is focused more.

// In most cases, ordinal and time do not suitable for label.

// Ordinal info can be displayed on axis. Time is too long.

// ??? FIXME extra coord should not be set in dataDimsOnCoord.

// But should fix the case that radar axes: simplify the logic

// of `completeDimension`, remove `extraPrefix`.

// Not necessary to remove duplicate, because a data

// dim canot on more than one coordDim.

// FIXME `encode.label` is not recommanded, because formatter can not be set

// in this way. Use label.formatter instead. May be remove this approach someday.

/**
     * @type {Object.<Array|TypedArray>}
     * @private
     */

// The cost of the copy is probably inconsiderable

// within the initial chunkSize.

// Create new chunks.

// Currently, only dimensions that has ordinalMeta can create inverted indices.

// The default value of TypedArray is 0. To avoid miss

// mapping to 0, we should set it as INDEX_NOT_FOUND.

// Only support the case that all values are distinct.

/**
 * Get raw data item
 * @param {number} idx
 * @return {number}
 */

// FIXME Check the usage in graph, should not use prefix.

// stroage may be empty when no data, so use

// dimensionInfos to check.

/**
 * Data iteration
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {*} [context=this]
 *
 * @example
 *  list.each('x', function (x, idx) {});
 *  list.each(['x', 'y'], function (x, y, idx) {});
 *  list.each(function (idx) {})
 */

// Data in excludeDimensions is copied, otherwise transfered.

// FIXME If needs stackedOn, value may already been stacked

// Init storage

// Notice that we do not reset invertedIndicesMap here, becuase

// there is no scenario of mapping or sampling ordinal dimension.

// Direct reference for other dimensions

/**
 * Data mapping to a new List with given dimensions
 * @param {string|Array.<string>} dimensions
 * @param {Function} cb
 * @param {*} [context=this]
 * @return {Array}
 */

/**
 * If each data item has it's own option
 * @type {boolean}
 */

/**
 * Get dimension name
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 * @return {string} Concrete dim name.
 */

/**
 * Get type and calculation info of particular dimension
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 */

// Do not clone, because there may be categories in dimInfo.

/**
 * @return {Array.<string>} concrete dimension name list on coord.
 */

/**
 * @param {string} coordDim
 * @param {number} [idx] A coordDim may map to more than one data dim.
 *        If idx is `true`, return a array of all mapped dims.
 *        If idx is not specified, return the first dim not extra.
 * @return {string|Array.<string>} concrete data dim.
 *        If idx is number, and not found, return null/undefined.
 *        If idx is `true`, and not found, return empty array (always return array).
 */

/**
 * Initialize from data
 * @param {Array.<Object|number|Array>} data source or data or data provider.
 * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and
 *        defualt label/tooltip.
 *        A name can be specified in encode.itemName,
 *        or dataItem.name (only for series option data),
 *        or provided in nameList from outside.
 * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
 */

// Clear

// Default dim value getter

// Reset raw extent.

// If data has no item option.

/**
 * Caution: Can be only called on raw data (before `this._indices` created).
 */

/**
 * Caution: Can be only called on raw data (before `this._indices` created).
 * This method does not modify `rawData` (`dataProvider`), but only
 * add values to storage.
 *
 * The final count will be increased by `Math.max(values.length, names.length)`.
 *
 * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like
 *        [
 *            [12, 33, 44],
 *            [NaN, 43, 1],
 *            ['-', 'asdf', 0]
 *        ]
 *        Each item is exaclty cooresponding to a dimension.
 * @param {Array.<string>} [names]
 */

// Store the data by dimensions

// Reset data extent

// Optimize.

// NOTICE: Try not to write things into dataItem

// Each data item is value

// [1, 2]

// 2

// Bar chart, line chart which uses category axis

// only gives the 'y' value. 'x' value is the indices of category

// Use a tempValue to normalize the value to be a (x, y) value

// ??? FIXME not check by pure but sourceFormat?

// TODO refactor these logic.

// If dataItem is {name: ...}, it has highest priority.

// That is appropriate for many common cases.

// There is no other place to persistent dataItem.name,

// so save it to nameList.

// Try using the id in option

// id or name is used on dynamical data, mapping old and new items.

// Use name as id and add counter to avoid same name

// Clean unused data if data source is typed array.

// `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

/**
 * Get value. Return NaN if idx is out of range.
 * @param {string} dim Dim must be concrete name.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */

/*, stack */

// TODO Warn ?

// FIXME ordinal data type is not stackable

// if (stack) {

//     var dimensionInfo = this._dimensionInfos[dim];

//     if (dimensionInfo && dimensionInfo.stackable) {

//         var stackedOn = this.stackedOn;

//         while (stackedOn) {

//             // Get no stacked data of stacked on

//             var stackedValue = stackedOn.get(dim, idx);

//             // Considering positive stack, negative stack and empty data

//             if ((value >= 0 && stackedValue > 0)  // Positive stack

//                 || (value <= 0 && stackedValue < 0) // Negative stack

//             ) {

//                 value += stackedValue;

//             stackedOn = stackedOn.stackedOn;

/**
 * @param {string} dim concrete dim
 * @param {number} rawIndex
 * @return {number|string}
 */

/**
 * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).
 * Hack a much simpler _getFast
 * @private
 */

/**
 * Get value for multi dimensions.
 * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
 * @param {number} idx
 * @return {number}
 */

// stack = idx;

/**
 * If value is NaN. Inlcuding '-'
 * Only check the coord dimensions.
 * @param {string} dim
 * @param {number} idx
 * @return {number}
 */

// Ordinal type can be string or number

/**
 * Get extent of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 */

// Make sure use concrete dim as cache name.

// stack = !!((stack || false) && this.getCalculationInfo(dim));

// Make more strict checkings to ensure hitting cache.

// var cacheName = [dim, !!stack].join('_');

// var cacheName = dim;

// Consider the most cases when using data zoom, `getDataExtent`

// happened before filtering. We cache raw extent, which is not

// necessary to be cleared and recalculated when restore data.

// var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));

/**
 * Optimize for the scenario that data is filtered by a given extent.
 * Consider that if data amount is more than hundreds of thousand,
 * extent calculation will cost more than 10ms and the cache will
 * be erased because of the filtering.
 */

/**
 * @param {string} key
 * @return {*}
 */

/**
 * @param {string|Object} key or k-v object
 * @param {*} [value]
 */

/**
 * Get sum of data in one dimension
 * @param {string} dim
 */

/**
 * Get median of data in one dimension
 * @param {string} dim
 */

// map all data of one dimension

// Use quick select?

// immutability & sort

// calculate median

//  * Retreive the index with given value

//  * @param {string} dim Concrete dimension.

//  * @param {number} value

//  * @return {number}

// Currently incorrect: should return dataIndex but not rawIndex.

// Do not fix it until this method is to be used somewhere.

// FIXME Precision of float value

// listProto.indexOf = function (dim, value) {

//     var storage = this._storage;

//     var dimData = storage[dim];

//     var chunkSize = this._chunkSize;

//     if (dimData) {

//         for (var i = 0, len = this.count(); i < len; i++) {

//             var chunkIndex = Math.floor(i / chunkSize);

//             var chunkOffset = i % chunkSize;

//             if (dimData[chunkIndex][chunkOffset] === value) {

//                 return i;

//     return -1;

/**
 * Only support the dimension which inverted index created.
 * Do not support other cases until required.
 * @param {string} concrete dim
 * @param {number|string} value
 * @return {number} rawIndex
 */

/**
 * Retreive the index with given name
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */

/**
 * Retreive the index with given raw data index
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */

// Indices are ascending

// If rawIndex === dataIndex

/**
 * Retreive the index of nearest value
 * @param {string} dim
 * @param {number} value
 * @param {number} [maxDistance=Infinity]
 * @return {Array.<number>} Considere multiple points has the same value.
 */

// For the case of two data are same on xAxis, which has sequence data.

// Show the nearest index

// https://github.com/ecomfe/echarts/issues/2869

/**
 * Get raw data index
 * @param {number} idx
 * @return {number}
 */

/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */

// contextCompat just for compat echarts3

// Simple optimization

// Index

/**
 * Data filter
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {*} [context=this]
 */

// Set indices after filtered.

/**
 * Select data in range. (For optimization of filter)
 * (Manually inline code, support 5 million data filtering in data zoom.)
 */

// Extreme optimization for common case. About 2x faster in chrome.

// NaN will not be filtered. Consider the case, in line chart, empty

// value indicates the line should be broken. But for the case like

// scatter plot, a data item with empty value will not be rendered,

// but the axis extent may be effected if some other dim of the data

// item has value. Fortunately it is not a significant negative effect.

// Do not filter NaN, see comment above.

/**
 * Data mapping to a plain array
 * @param {string|Array.<string>} [dimensions]
 * @param {Function} cb
 * @param {*} [context=this]
 * @return {Array}
 */

// Following properties are all immutable.

// So we can reference to the same value

// a number or string (in oridinal dimension)?

/**
 * Large data down sampling on given dimension
 * @param {string} dimension
 * @param {number} rate
 * @param {Function} sampleValue
 * @param {Function} sampleIndex Sample index for name and id
 */

// Last frame

// Only write value on the filtered data

/**
 * Get model of one data item.
 *
 * @param {number} idx
 */

// FIXME Model proxy ?

/**
 * Create a data differ
 * @param {module:echarts/data/List} otherList
 * @return {module:echarts/data/DataDiffer}
 */

/**
 * Get visual property.
 * @param {string} key
 */

/**
 * Set visual property
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setVisual('color', color);
 *  setVisual({
 *      'color': color
 *  });
 */

/**
 * Set layout property.
 * @param {string|Object} key
 * @param {*} [val]
 */

/**
 * Get layout property.
 * @param  {string} key.
 * @return {*}
 */

/**
 * Get layout of single data item
 * @param {number} idx
 */

/**
 * Set layout of single data item
 * @param {number} idx
 * @param {Object} layout
 * @param {boolean=} [merge=false]
 */

/**
 * Clear all layout of single data item
 */

/**
 * Get visual property of single data item
 * @param {number} idx
 * @param {string} key
 * @param {boolean} [ignoreParent=false]
 */

/**
 * Set visual property of single data item
 *
 * @param {number} idx
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setItemVisual(0, 'color', color);
 *  setItemVisual(0, {
 *      'color': color
 *  });
 */

/**
 * Clear itemVisuals and list visual.
 */

/**
 * @deprecated
 * Use `echarts/data/helper/createDimensions` instead.
 */

/**
 * @see {module:echarts/test/ut/spec/data/completeDimensions}
 *
 * Complete the dimensions array, by user defined `dimension` and `encode`,
 * and guessing from the data structure.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
 *      provides not only dim template, but also default order.
 *      properties: 'name', 'type', 'displayName'.
 *      `name` of each item provides default coord name.
 *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and
 *                                    provide dims count that the sysDim required.
 *      [{ordinalMeta}] can be specified.
 * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)
 * @param {Object} [opt]
 * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
 *      For example: ['asdf', {name, type}, ...].
 * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
 * @param {string} [opt.generateCoord] Generate coord dim with the given name.
 *                 If not specified, extra dim names will be:
 *                 'value', 'value0', 'value1', ...
 * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.
 *                 If `generateCoordCount` specified, the generated dim names will be:
 *                 `generateCoord` + 0, `generateCoord` + 1, ...
 *                 can be Infinity, indicate that use all of the remain columns.
 * @param {number} [opt.dimCount] If not specified, guess by the first data item.
 * @param {number} [opt.encodeDefaulter] If not specified, auto find the next available data dim.
 * @return {Array.<Object>} [{
 *      name: string mandatory,
 *      displayName: string, the origin name in dimsDef, see source helper.
 *                 If displayName given, the tooltip will displayed vertically.
 *      coordDim: string mandatory,
 *      coordDimIndex: number mandatory,
 *      type: string optional,
 *      otherDims: { never null/undefined
 *          tooltip: number optional,
 *          label: number optional,
 *          itemName: number optional,
 *          seriesName: number optional,
 *      },
 *      isExtraCoord: boolean true if coord is generated
 *          (not specified in encode and not series specified)
 *      other props ...
 * }]
 */

// Apply user defined dims (`name` and `type`) and init result.

// ??? TODO

// Originally detect dimCount by data[0]. Should we

// optimize it to only by sysDims and dimensions and encode.

// So only necessary dims will be initialized.

// But

// (1) custom series should be considered. where other dims

// may be visited.

// (2) sometimes user need to calcualte bubble size or use visualMap

// on other dimensions besides coordSys needed.

// So, dims that is not used by system, should be shared in storage?

// Note that the result dimCount should not small than columns count

// of data, otherwise `dataDimNameMap` checking will be incorrect.

// Name will be applied later for avoiding duplication.

// Only if `series.dimensions` is defined in option

// displayName, will be set, and dimension will be diplayed vertically in

// tooltip by default.

// Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.

// Note: It is allowed that `dataDims.length` is `0`, e.g., options is

// `{encode: {x: -1, y: 1}}`. Should not filter anything in

// this case.

// The input resultDimIdx can be dim name or index.

// Apply templetes and default order from `sysDims`.

// Make sure the first extra dim is 'value'.

// `coordDimIndex` should not be set directly.

// negative resultDimIdx means no need to mapping.

// dimensions provides default dim sequences.

// Apply templates.

// FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}

// Set dim `name` and other `coordDim` and other props.

/**
 * Substitute `completeDimensions`.
 * `completeDimensions` is to be deprecated.
 */

/**
 * @param {module:echarts/data/Source|module:echarts/data/List} source or data.
 * @param {Object|Array} [opt]
 * @param {Array.<string|Object>} [opt.coordDimensions=[]]
 * @param {number} [opt.dimensionsCount]
 * @param {string} [opt.generateCoord]
 * @param {string} [opt.generateCoordCount]
 * @param {Array.<string|Object>} [opt.dimensionsDefine=source.dimensionsDefine] Overwrite source define.
 * @param {Object|HashMap} [opt.encodeDefine=source.encodeDefine] Overwrite source define.
 * @return {Array.<Object>} dimensionsInfo
 */

/**
 * Set graphic element relative to data. It can be set as null
 * @param {number} idx
 * @param {module:zrender/Element} [el]
 */

// Add data index and series index for indexing the data by element

// Useful in tooltip

/**
 * @param {number} idx
 * @return {module:zrender/Element}
 */

/**
 * @param {Function} cb
 * @param {*} context
 */

/**
 * Shallow clone a new list except visual and layout properties, and graph elements.
 * New list only change the indices.
 */

// Clone will not change the data extent and indices

/**
 * Wrap some method to add more feature
 * @param {string} methodName
 * @param {Function} injectFunction
 */

// Methods that create a new list based on this list should be listed here.

// Notice that those method should `RETURN` the new list.

// Methods that change indices of this list should be listed here.

/**
 * Note that it is too complicated to support 3d stack by value
 * (have to create two-dimension inverted index), so in 3d case
 * we just support that stacked by index.
 *
 * @param {module:echarts/model/Series} seriesModel
 * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.
 *        The input dimensionInfoList will be modified.
 * @param {Object} [opt]
 * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.
 * @param {boolean} [opt.byIndex=false]
 * @return {Object} calculationInfo
 * {
 *     stackedDimension: string
 *     stackedByDimension: string
 *     isStackedByIndex: boolean
 *     stackedOverDimension: string
 *     stackResultDimension: string
 * }
 */

// Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.

// That put stack logic in List is for using conveniently in echarts extensions, but it

// might not be a good way.

// Find the first ordinal dimension as the stackedByDimInfo.

// Find the first stackable dimension as the stackedDimInfo.

// Compatible with previous design, value axis (time axis) only stack by index.

// It may make sense if the user provides elaborately constructed data.

// Use a weird name that not duplicated with other names.

// Create inverted index to fast query index by value.

// This dimension contains stack base (generally, 0), so do not set it as

// `stackedDimCoordDim` to avoid extent calculation, consider log scale.

/**
 * @param {module:echarts/data/List} data
 * @param {string} stackedDim
 */

/*, stackedByDim*/

// Each single series only maps to one pair of axis. So we do not need to

// check stackByDim, whatever stacked by a dimension or stacked by index.

// && (

//     stackedByDim != null

//         ? stackedByDim === data.getCalculationInfo('stackedByDimension')

//         : data.getCalculationInfo('isStackedByIndex')

/**
 * @param {module:echarts/data/List} data
 * @param {string} targetDim
 * @param {string} [stackedByDim] If not input this parameter, check whether
 *                                stacked by index.
 * @return {string} dimension
 */

/**
 * @param {module:echarts/data/Source|Array} source Or raw data.
 * @param {module:echarts/model/Series} seriesModel
 * @param {Object} [opt]
 * @param {string} [opt.generateCoord]
 */

// Get dimensions from registered coordinate system

/**
 * // Scale class management
 * @module echarts/scale/Scale
 */

/**
 * @param {Object} [setting]
 */

// Use dataIndex as ordinal value in categoryAxis

/**
     * Extent
     * @type {Array.<number>}
     * @protected
     */

/**
     * Step is calculated in adjustExtent
     * @type {Array.<number>}
     * @protected
     */

/**
 * Parse input val to valid inner number.
 * @param {*} val
 * @return {number}
 */

/**
 * @constructor
 * @param {Object} [opt]
 * @param {Object} [opt.categories=[]]
 * @param {Object} [opt.needCollect=false]
 * @param {Object} [opt.deduplication=false]
 */

/**
 * @param {module:echarts/model/Model} axisModel
 * @return {module:echarts/data/OrdinalMeta}
 */

// Notice: This would be a trap here, If the implementation

// of this method depends on extent, and this method is used

// before extent set (like in dataZoom), it would be wrong.

// Nevertheless, parse does not depend on extent generally.

/**
 * Normalize value to linear [0, 1], return 0.5 if extent span is 0
 * @param {number} val
 * @return {number}
 */

/**
 * Scale normalized value
 * @param {number} val
 * @return {number}
 */

/**
 * Set extent from data
 * @param {Array.<number>} other
 */

/**
 * Set extent from data
 * @param {module:echarts/data/List} data
 * @param {string} dim
 */

/**
 * Get extent
 * @return {Array.<number>}
 */

/**
 * Set extent
 * @param {number} start
 * @param {number} end
 */

/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */

/**
 * @abstract
 * @param {*} tick
 * @return {string} label of the tick.
 */

// deduplication is default in axis.

/**
 * @param {string} category
 * @return {number} ordinal
 */

// Consider big data, do not create map until needed.

/**
 * Linear continuous scale
 * @module echarts/coord/scale/Ordinal
 *
 * http://en.wikipedia.org/wiki/Level_of_measurement
 */

// FIXME only one data

/**
 * @param {*} category
 * @return {number} The ordinal. If not found, return NaN.
 */

// The value of category dim can be the index of the given category set.

// This feature is only supported when !needCollect, because we should

// consider a common case: a value is 2017, which is a number but is

// expected to be tread as a category. This case usually happen in dataset,

// where it happent to be no need of the index feature.

// Optimize for the scenario:

// category is ['2012-01-01', '2012-01-02', ...], where the input

// data has been ensured not duplicate and is large data.

// Notice, if a dataset dimension provide categroies, usually echarts

// should remove duplication except user tell echarts dont do that

// (set axis.deduplication = false), because echarts do not know whether

// the values in the category dimension has duplication (consider the

// parallel-aqi example)

/**
     * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
     */

// Caution: Should not use instanceof, consider ec-extensions using

// import approach to get OrdinalMeta class.

/**
     * Normalize given rank or name to linear [0, 1]
     * @param {number|string} [val]
     * @return {number}
     */

/**
     * @return {Array}
     */

/**
     * Get item on rank n
     * @param {number} n
     * @return {string}
     */

// Note that if no data, ordinalMeta.categories is an empty array.

/**
     * @override
     */

/**
 * @return {module:echarts/scale/Time}
 */

/**
 * For testable.
 */

/**
 * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
 *                                Should be extent[0] < extent[1].
 * @param {number} splitNumber splitNumber should be >= 1.
 * @param {number} [minInterval]
 * @param {number} [maxInterval]
 * @return {Object} {interval, intervalPrecision, niceTickExtent}
 */

/**
 * @param {number} interval
 * @return {number} interval precision
 */

// Tow more digital for tick.

// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.

/**
 * Interval scale
 * @module echarts/scale/Interval
 */

//start,end may be a Number like '25',so...

// unionExtent may called by it's sub classes

/**
     * Get interval
     */

/**
     * Set interval
     */

// Dropped auto calculated niceExtent and use user setted extent

// We assume user wan't to set both interval, min, max to get a better result

// If interval is 0, return [];

// Consider this case: using dataZoom toolbox, zoom and zoom.

// Avoid rounding error

// Consider this case: the last item of ticks is smaller

// than niceTickExtent[1] and niceTickExtent[1] === extent[1].

/**
     * @param {number} data
     * @param {Object} [opt]
     * @param {number|string} [opt.precision] If 'auto', use nice presision.
     * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
     * @return {string}
     */

// Should be more precise then tick.

// (1) If `precision` is set, 12.005 should be display as '12.00500'.

// (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.

/**
     * Update interval and extent of intervals for nice ticks
     *
     * @param {number} [splitNumber = 5] Desired number of ticks
     * @param {number} [minInterval]
     * @param {number} [maxInterval]
     */

// User may set axis min 0 and data are all negative

// FIXME If it needs to reverse ?

// Niced extent inside original extent

/**
     * Nice extent.
     * @param {Object} opt
     * @param {number} [opt.splitNumber = 5] Given approx tick number
     * @param {boolean} [opt.fixMin=false]
     * @param {boolean} [opt.fixMax=false]
     * @param {boolean} [opt.minInterval]
     * @param {boolean} [opt.maxInterval]
     */

// If extent start and end are same, expand them

// Expand extent

// In the fowllowing case

//      Axis has been fixed max 100

//      Plus data are all 100 and axis extent are [100, 100].

// Extend to the both side will cause expanded max is larger than fixed max.

// So only expand to the smaller side.

// If there are no data and extent are [Infinity, -Infinity]

// var extent = this._extent;

/**
 * @alias module:echarts/coord/scale/Interval
 * @constructor
 */

/* global Float32Array */

/**
 * @param {Object} opt
 * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
 * @param {number} opt.count Positive interger.
 * @param {number} [opt.barWidth]
 * @param {number} [opt.barMaxWidth]
 * @param {number} [opt.barGap]
 * @param {number} [opt.barCategoryGap]
 * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
 */

// Check series coordinate, do layout for cartesian2d only

// Columns info on each category axis. Key is cartesian name

// Caution: In a single coordinate system, these barGrid attributes

// will be shared by series. Consider that they have default values,

// only the attributes set on the last series will work.

// Do not change this fact unless there will be a break change.

// See #6312, do not restrict width.

// Find if any auto calculated bar exceeded maxBarWidth

// Recalculate width again

/**
 * @param {Object} barWidthAndOffset The result of makeColumnLayout
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.
 * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.
 */

/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 */

// TODO: Do not support stack in large mode yet.

// See cases in `test/bar-start.html` and `#7412`, `#8747`.

/*
* A third-party license is embeded for some of the code in this file:
* The "scaleLevels" was originally copied from "d3.js" with some
* modifications made for this project.
* (See more details in the comment on the definition of "scaleLevels" below.)
* The use of the source code of this file is also subject to the terms
* and consitions of the license of "d3.js" (BSD-3Clause, see
* </licenses/LICENSE-d3>).
*/

// [About UTC and local time zone]:

// In most cases, `number.parseDate` will treat input data string as local time

// (except time zone is specified in time string). And `format.formateTime` returns

// local time by default. option.useUTC is false by default. This design have

// concidered these common case:

// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed

// in local time by default.

// (2) By default, the input data string (e.g., '2011-01-02') should be displayed

// as its original time, without any time difference.

// Same with interval scale if span is much larger than 1 year

// Interval will be used in getTicks

// val might be float.

/**
 * This implementation was originally copied from "d3.js"
 * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 */

// Format              interval

// 1s

// 5s

// 10s

// 15s

// 30s

// 1m

// 5m

// 10m

// 15m

// 30m

// 1h

// 2h

// 6h

// 12h

// 1d

// 2d

// 3d

// 4d

// 5d

// 6d

// 7d

// 10d

// 2w

// 3w

// 1M

// 6w

// 2M

// 10w

// 3M

// 4M

// 5M

// 6M

// 8M

// 10M

/**
 * @param {module:echarts/model/Model}
 * @return {module:echarts/scale/Time}
 */

/**
 * Log scale
 * @module echarts/scale/Log
 */

// Use some method of IntervalScale

// Fix #4158

/**
     * @param {number} val
     * @return {string}
     */

/**
     * @param  {number} val
     * @return {number}
     */

/**
     * @param {number} start
     * @param {number} end
     */

/**
     * @return {number} end
     */

/**
     * @param  {Array.<number>} extent
     */

// filter value that <= 0

/**
     * Update interval and extent of intervals for nice ticks
     * @param  {number} [approxTickNum = 10] Given approx tick number
     */

// Interval should be integer

// Filter ticks to get closer to the desired count.

/**
     * Nice extent.
     * @override
     */

/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 */

// Notice: When min/max is not set (that is, when there are null/undefined,

// which is the most common case), these cases should be ensured:

// (1) For 'ordinal', show all axis.data.

// (2) For others:

//      + `boundaryGap` is applied (if min/max set, boundaryGap is

//      disabled).

//      + If `needCrossZero`, min/max should be zero, otherwise, min/max should

//      be the result that originalExtent enlarged by boundaryGap.

// (3) If no data, it should be ensured that `scale.setBlank` is set.

// (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?

// (2) When `needCrossZero` and all data is positive/negative, should it be ensured

// that the results processed by boundaryGap are positive/negative?

// Evaluate if axis needs cross zero

// Axis is over zero and min is not set

// Axis is under zero and max is not set

// If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis

// is base axis

// (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.

// (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?

//     Should not depend on series type `bar`?

// (3) Fix that might overlap when using dataZoom.

// (4) Consider other chart types using `barGrid`?

// See #6728, #4862, `test/bar-overflow-time-plot.html`

/*|| scaleType === 'interval' */

// Calculate placement of bars on axis

// Get Axis Length

// Calulate required buffer based on old range and overflow

// Adjust axis min and max to account for overflow

// If some one specified the min, max. And the default calculated interval

// is not good enough. He can specify the interval. It is often appeared

// in angle axis with angle 0 - 360. Interval calculated in interval scale is hard

// to be 60.

/**
 * @param {module:echarts/model/Model} model
 * @param {string} [axisType] Default retrieve from model.type
 * @return {module:echarts/scale/*}
 */

// Buildin scale

// Extended scale, like time and log

/**
 * Check if the axis corss 0
 */

/**
 * @param {module:echarts/coord/Axis} axis
 * @return {Function} Label formatter function.
 *         param: {number} tickValue,
 *         param: {number} idx, the index in all ticks.
 *                         If category axis, this param is not requied.
 *         return: {string} label string.
 */

// For category axis, get raw value; for numeric axis,

// get foramtted label like '1,333,444'.

// The original intention of `idx` is "the index of the tick in all ticks".

// But the previous implementation of category axis do not consider the

// `axisLabel.interval`, which cause that, for example, the `interval` is

// `1`, then the ticks "name5", "name7", "name9" are displayed, where the

// corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep

// the definition here for back compatibility.

// In category axis with data zoom, tick is not the original

// index of axis.data. So tick should not be exposed to user

// in category axis.

/**
 * @param {module:echarts/coord/Axis} axis
 * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.
 */

/**
 * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel
 * @return {number|String} Can be null|'auto'|number|function
 */

/**
 * Set `categoryInterval` as 0 implicitly indicates that
 * show all labels reguardless of overlap.
 * @param {Object} axis axisModel.axis
 * @return {boolean}
 */

// import * as axisHelper from './axisHelper';

/**
     * @param {boolean} origin
     * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
     */

/**
     * @param {boolean} origin
     * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
     */

/**
     * Should be implemented by each axis model if necessary.
     * @return {module:echarts/model/Component} coordinate system model
     */

/**
     * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
     * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
     */

/**
     * Reset range
     */

// rangeStart and rangeEnd is readonly.

// x, y on the cusp

// Put circle in the center of square

// Symbol factory

/**
 * Triangle shape
 * @inner
 */

// Default rect

// Provide setColor helper method to avoid determine if set the fill or stroke outside

// FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?

/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @param {string} symbolType
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
 *                            for path and image only.
 */

// TODO Support image object, DynamicImage.

// import createGraphFromNodeEdge from './chart/helper/createGraphFromNodeEdge';

/**
 * Create a muti dimension List structure from seriesModel.
 * @param  {module:echarts/model/Model} seriesModel
 * @return {module:echarts/data/List} list
 */

/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option
 */

/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 * `setRange(start: number, end: number)`
 * `resetRange()`
 */

// Close polygon

/**
 * @module echarts/coord/geo/Region
 */

/**
 * @param {string|Region} name
 * @param {Array} geometries
 * @param {Array.<number>} cp
 */

/**
     * @type {Array.<Array>}
     * @readOnly
     */

// ZigZag decoding

// Delta deocding

// Dequantize

/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */

// Only support polygon

// Doesn't consider hole

/**
     * @param {<Array.<number>} coord
     * @return {boolean}
     */

// Only support polygon.

// Not in the region if point is in the hole.

// Update center

// Simply avoid to be called.

/**
 * Parse and decode geo json
 * @module echarts/coord/geo/parseGeoJson
 */

// Has been decoded

// Output of mapshaper may have geometry null

// According to the GeoJSON specification.

// First must be exterior, and the rest are all interior(holes).

/**
 * @param {module:echats/coord/Axis} axis
 * @return {Object} {
 *     labels: [{
 *         formattedLabel: string,
 *         rawLabel: string,
 *         tickValue: number
 *     }, ...],
 *     labelCategoryInterval: number
 * }
 */

// Only ordinal scale support tick interval

// Large category data calculation is performence sensitive, and ticks and label

// probably be fetched by multiple times. So we cache the result.

// axis is created each time during a ec process, so we do not need to clear cache.

/**
 * @param {module:echats/coord/Axis} axis
 * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
 * @return {Object} {
 *     ticks: Array.<number>
 *     tickCategoryInterval: number
 * }
 */

// Optimize for the case that large category data and no label displayed,

// we should not return all ticks.

// Cache to avoid calling interval function repeatly.

/**
 * Calculate interval for category axis ticks and labels.
 * To get precise result, at least one of `getRotate` and `isHorizontal`
 * should be implemented in axis.
 */

// Because key can be funciton, and cache size always be small, we use array cache.

// Calculate start tick based on zero if possible to keep label consistent

// while zooming and moving while interval > 0. Otherwise the selection

// of displayable ticks and symbols probably keep changing.

// 3 is empirical value.

// (1) Only add min max label here but leave overlap checking

// to render stage, which also ensure the returned list

// suitable for splitLine and splitArea rendering.

// (2) Scales except category always contain min max label so

// do not need to perform this process.

// Optimize: avoid generating large array by `ordinalScale.getTicks()`.

// When interval is function, the result `false` means ignore the tick.

// It is time consuming for large category data.

/**
     * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'.
     * @type {string}
     */

/**
     * Axis scale
     * @type {module:echarts/coord/scale/*}
     */

/**
     * Usually true when axis has a ordinal scale
     * @type {boolean}
     */

/**
 * Base class of Axis.
 * @constructor
 */

// If axis has labels [1, 2, 3, 4]. Bands on the axis are

// |---1---|---2---|---3---|---4---|.

// So the displayed ticks and splitLine/splitArea should between

// each data item, otherwise cause misleading (e.g., split tow bars

// of a single data item when there are two bar series).

// Also consider if tickCategoryInterval > 0 and onBand, ticks and

// splitLine/spliteArea should layout appropriately corresponding

// to displayed labels. (So we should not use `getBandWidth` in this

// case).

/**
     * If axis extent contain given coord
     * @param {number} coord
     * @return {boolean}
     */

/**
     * If axis extent contain given data
     * @param {number} data
     * @return {boolean}
     */

/**
     * Get coord extent.
     * @return {Array.<number>}
     */

/**
     * Get precision used for formatting
     * @param {Array.<number>} [dataExtent]
     * @return {number}
     */

/**
     * Set coord extent
     * @param {number} start
     * @param {number} end
     */

/**
     * Convert data to coord. Data is the rank if it has an ordinal scale
     * @param {number} data
     * @param  {boolean} clamp
     * @return {number}
     */

/**
     * Convert coord to data. Data is the rank if it has an ordinal scale
     * @param {number} coord
     * @param  {boolean} clamp
     * @return {number}
     */

/**
     * Convert pixel point to data in axis
     * @param {Array.<number>} point
     * @param  {boolean} clamp
     * @return {number} data
     */

// Should be implemented in derived class if necessary.

/**
     * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
     * `axis.getTicksCoords` considers `onBand`, which is used by
     * `boundaryGap:true` of category axis and splitLine and splitArea.
     * @param {Object} [opt]
     * @param {number} [opt.tickModel=axis.model.getModel('axisTick')]
     * @param {boolean} [opt.clamp] If `true`, the first and the last
     *        tick must be at the axis end points. Otherwise, clip ticks
     *        that outside the axis extent.
     * @return {Array.<Object>} [{
     *     coord: ...,
     *     tickValue: ...
     * }, ...]
     */

// Avoid split a single data item when odd interval.

/**
 * Do not mount those modules on 'src/echarts' for better tree shaking.
 */

/**
     * @return {Array.<Object>} [{
     *     formattedLabel: string,
     *     rawLabel: axis.scale.getLabel(tickValue)
     *     tickValue: number
     * }, ...]
     */

/**
     * @return {module:echarts/coord/model/Model}
     */

/**
     * Notice here we only get the default tick model. For splitLine
     * or splitArea, we should pass the splitLineModel or splitAreaModel
     * manually when calling `getTicksCoords`.
     * In GL, this method may be overrided to:
     * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
     * @return {module:echarts/coord/model/Model}
     */

/**
     * Get width of band
     * @return {number}
     */

// Fix #2728, avoid NaN when only one data.

/**
     * @abstract
     * @return {boolean} Is horizontal
     */

/**
     * @abstract
     * @return {number} Get axis rotate, by degree.
     */

/**
     * Only be called in category axis.
     * Can be overrided, consider other axes like in 3D.
     * @return {number} Auto interval for cateogry axis tick and label
     */

// Simple optimization. Empirical value: tick count should less than 40.

// Caution: Performance sensitive for large category data.

// Consider dataZoom, we should make appropriate step to avoid O(n) loop.

// Magic number

// Min size, void long loop.

// 0/0 is NaN, 1/0 is Infinity.

// Use cache to keep interval stable while moving zoom window,

// otherwise the calculated interval might jitter when the zoom

// window size is close to the interval-changing size.

/**
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @return {string} label string. Not null/undefined
 */

// Simple optimization (in lots of cases, label dims length is 1)

/**
 * @module echarts/chart/helper/Symbol
 */

/**
 * @constructor
 * @alias {module:echarts/chart/helper/Symbol}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */

// stack: null

// xAxisIndex: 0,

// yAxisIndex: 0,

// polarIndex: 0,

// If clip the overflow value

// cursor: null,

// itemStyle: {

// areaStyle: {

// origin of areaStyle. Valid values:

// `'auto'/null/undefined`: from axisLine to data

// `'start'`: from min to data

// `'end'`: from data to max

// origin: 'auto'

// false, 'start', 'end', 'middle'

// Disabled if step is true

// `false`: follow the label interval strategy.

// `true`: show all symbols.

// `'auto'`: If possible, show all symbols, otherwise

//           follow the label interval strategy.

// Whether to connect break point.

// Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.

// Disable progressive

/**
 * @public
 * @static
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @return {Array.<number>} [width, height]
 */

// Remove paths created before

// var symbolPath = createSymbol(

//     symbolType, -0.5, -0.5, 1, 1, color

// If width/height are set too small (e.g., set to 1) on ios10

// and macOS Sierra, a circle stroke become a rect, no matter what

// the scale is set. So we set width/height as 2. See #4150.

// Rewrite drift method

/**
 * Stop animation
 * @param {boolean} toLastFrame
 */

/**
 * FIXME:
 * Caution: This method breaks the encapsulation of this module,
 * but it indeed brings convenience. So do not use the method
 * unless you detailedly know all the implements of `Symbol`,
 * especially animation.
 *
 * Get symbol path element.
 */

/**
 * Get scale(aka, current symbol size).
 * Including the change caused by animation
 */

/**
 * Highlight symbol
 */

/**
 * Downplay symbol
 */

/**
 * @param {number} zlevel
 * @param {number} z
 */

/**
 * Update symbol properties
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Object} [seriesScope]
 * @param {Object} [seriesScope.itemStyle]
 * @param {Object} [seriesScope.hoverItemStyle]
 * @param {Object} [seriesScope.symbolRotate]
 * @param {Object} [seriesScope.symbolOffset]
 * @param {module:echarts/model/Model} [seriesScope.labelModel]
 * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
 * @param {boolean} [seriesScope.hoverAnimation]
 * @param {Object} [seriesScope.cursorStyle]
 * @param {module:echarts/model/Model} [seriesScope.itemModel]
 * @param {string} [seriesScope.symbolInnerColor]
 * @param {Object} [seriesScope.fadeIn=false]
 */

// Update common properties

// see comment in `graphic.isInEmphasis`

// Do not support this hover animation util some scenario required.

// Animation can only be supported in hover layer when using `el.incremetal`.

/**
 * @param {Function} cb
 * @param {Object} [opt]
 * @param {Object} [opt.keepLabel=true]
 */

/**
 * @module echarts/chart/helper/SymbolDraw
 */

/**
 * @constructor
 * @alias module:echarts/chart/helper/SymbolDraw
 * @param {module:zrender/graphic/Group} [symbolCtor]
 */

/**
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Array.<number>} symbolSize
 * @param {Object} [seriesScope]
 */

// Reset style

// Color must be excluded.

// Because symbol provide setColor individually to set fill and stroke

// PENDING setColor before setStyle!!!

// Do not execute util needed.

// Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.

// Note: consider `off`, should use static function here.

// Avoid mistaken hover when fading out

// Not show text when animating

/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Object} [opt] Or isIgnore
 * @param {Function} [opt.isIgnore]
 * @param {Object} [opt.clipShape]
 */

/**
 * @param {Object} coordSys
 * @param {module:echarts/data/List} data
 * @param {string} valueOrigin lineSeries.option.areaStyle.origin
 */

// Both positive

/*, dims[1]*/

/*, dims[0]*/

// var arrayDiff = require('zrender/src/core/arrayDiff');

// 'zrender/src/core/arrayDiff' has been used before, but it did

// not do well in performance when roam with fixed dataZoom window.

// function convertToIntId(newIdList, oldIdList) {

//     // Generate int id instead of string id.

//     // Compare string maybe slow in score function of arrDiff

//     // Assume id in idList are all unique

//     var idIndicesMap = {};

//     var idx = 0;

//     for (var i = 0; i < newIdList.length; i++) {

//         idIndicesMap[newIdList[i]] = idx;

//         newIdList[i] = idx++;

//     for (var i = 0; i < oldIdList.length; i++) {

//         var oldId = oldIdList[i];

//         // Same with newIdList

//         if (idIndicesMap[oldId]) {

//             oldIdList[i] = idIndicesMap[oldId];

//         else {

//             oldIdList[i] = idx++;

// There is no oldLineData only when first rendering or switching from

// stream mode to normal mode, where previous elements should be removed.

// Add back

// Not use animation

// Incremental model do not have this._data.

// Poly path support NaN point

// if (smoothMonotone == null) {

//     if (isMono(points, 'x')) {

//         return drawMono(ctx, points, start, segLen, allLen,

//             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);

//     else if (isMono(points, 'y')) {

//             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);

//     else {

//         return drawNonMono.apply(this, arguments);

// else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {

//     return drawMono.apply(this, arguments);

//     return drawNonMono.apply(this, arguments);

/**
 * Check if points is in monotone.
 *
 * @param {number[][]} points         Array of points which is in [x, y] form
 * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which
 *                                    dimension that is checking.
 *                                    If is 'none', `drawNonMono` should be
 *                                    called.
 *                                    If is undefined, either being monotone
 *                                    in 'x' or 'y' will call `drawMono`.
 */

// function isMono(points, smoothMonotone) {

//     if (points.length <= 1) {

//         return true;

//     var dim = smoothMonotone === 'x' ? 0 : 1;

//     var last = points[0][dim];

//     var lastDiff = 0;

//     for (var i = 1; i < points.length; ++i) {

//         var diff = points[i][dim] - last;

//         if (!isNaN(diff) && !isNaN(lastDiff)

//             && diff !== 0 && lastDiff !== 0

//             && ((diff >= 0) !== (lastDiff >= 0))

//             return false;

//         if (!isNaN(diff) && diff !== 0) {

//             lastDiff = diff;

//             last = points[i][dim];

/**
 * Draw smoothed line in monotone, in which only vertical or horizontal bezier
 * control points will be used. This should be used when points are monotone
 * either in x or y dimension.
 */

/**
 * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
 * situations. This should be used when points are non-monotone neither in x or
 * y dimension.
 */

// Find next point not null

// Last point

// If next data is null in not connect case

// Use ratio of seg length

// Smooth constraint

// cp0 of next segment

// Must remove first and last null values avoid draw error in polygon

// Offset between stacked base points and points

// FIXME step not support polar

// Remove extra 1px to avoid line miter in clipped edge

/**
 * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
 * @param {module:echarts/data/List} data
 * @param {Object} dataCoordInfo
 * @param {Array.<Array.<number>>} points
 */

// Avoid float number rounding error for symbol on the edge of axis extent.

// See #7913 and `test/dataZoom-clip.html`.

// Expand clip shape to avoid clipping when line value exceeds axis

// default is start

// Last points

// In mose cases, line is monotonous on category axis, and the label size

// is close with each other. So we check the symbol size and some of the

// label size alone with the category axis to estimate whether all symbol

// can be shown without overlap.

// 0/0 is NaN.

// Sampling some points, max 5.

// Note that category label interval strategy might bring some weird effect

// in some scenario: users may wonder why some of the symbols are not

// displayed. So we show all symbols as possible as we can.

// Otherwise follow the label interval strategy on category axis.

// Remove previous created symbols if showSymbol changed to false

// Initialization animation or coordinate system changed

// If areaStyle is added

// If areaStyle is removed

// Update clipPath

// Always update, or it is wrong in the case turning on legend

// because points are not changed

// Stop symbol animation and sync with line points

// FIXME performance?

// In the case data zoom triggerred refreshing frequently

// Data may not change if line has a category axis. So it should animate nothing

// Not do it in update with animation

// TODO If stacked series is not step

// Can only be x or y

// If the area to be rendered is bigger than area defined by LinearGradient,

// the canvas spec prescribes that the color of the first stop and the last

// stop should be used. But if two stops are added at offset 0, in effect

// browsers use the color of the second stop to render area outside

// LinearGradient. So we can only infinitesimally extend area defined in

// LinearGradient to render `outerColors`.

// dataToCoor mapping may not be linear, but must be monotonic.

// Arbitrary value: 10px

// notice colorStops.length have been changed.

// zrUtil.each(colorStops, function (colorStop) {

//     // Make sure each offset has rounded px to avoid not sharp edge

//     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);

// Use color in lineStyle first

// Save the coordinate system for transition animation when data changed

// Create a temporary symbol if it is not exists

// Null data

// Stop scale animation

// Highlight whole series

// can not downplay completely.

// Downplay whole series

/**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} points
     * @private
     */

// Remove previous created polyline

/**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} stackedOnPoints
     * @param {Array.<Array.<number>>} points
     * @private
     */

// Remove previous created polygon

/**
     * @private
     */

// FIXME Two value axis

// var newIdList = newData.mapArray(newData.getId);

// var oldIdList = oldData.mapArray(oldData.getId);

// convertToIntId(newIdList, oldIdList);

// // FIXME One data ?

// diff = arrayDiff(oldIdList, newIdList);

// FIXME, animation is not so perfect when dataZoom window moves fast

// Which is in case remvoing or add more than one data in the tail or head

// If previous data is NaN, use next point directly

// Data is replaced. In the case of dynamic data queue

// FIXME FIXME FIXME

// Original indices

// Diff result may be crossed if all items are changed

// Sort by data index

// `diff.current` is subset of `current` (which should be ensured by

// turnPointsIntoStep), so points in `__points` can be updated when

// points in `current` are update during animation.

// Remove temporary created elements when highlighting

// Encoding visual for all series include which is filtered for legend drawing

// For legend.

// If has item symbol

// PENDING Transform symbolSize ?

// Also {Array.<number>}, not undefined to avoid if...else... statement

// Return NaN if count is 0

// Ignore NaN

// NaN will cause illegal axis extent.

// Median

/**
 * Cartesian coordinate system
 * @module  echarts/coord/Cartesian
 *
 */

/**
 * @alias module:echarts/coord/Cartesian
 * @constructor
 */

/**
     * Get axis
     * @param  {number|string} dim
     * @return {module:echarts/coord/Cartesian~Axis}
     */

/**
     * Get axes list
     * @return {Array.<module:echarts/coord/Cartesian~Axis>}
     */

/**
     * Get axes list by given scale type
     */

/**
     * Add axis
     * @param {module:echarts/coord/Cartesian.Axis}
     */

/**
     * Convert data to coord in nd space
     * @param {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */

/**
     * Convert coord in nd space to data
     * @param  {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */

/**
     * @type {Array.<string>}
     * @readOnly
     */

/**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/cartesian/Axis2D}
     */

/**
     * If contain point
     * @param {Array.<number>} point
     * @return {boolean}
     */

/**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */

/**
     * @param {Array.<number>} data
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */

/**
     * @param {Array.<number>} point
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */

/**
     * Get other axis
     * @param {module:echarts/coord/cartesian/Axis2D} axis
     */

/**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */

/**
     * Axis position
     *  - 'top'
     *  - 'bottom'
     *  - 'left'
     *  - 'right'
     */

/**
     * Index of axis, can be used as key
     */

/**
     * Implemented in <module:echarts/coord/cartesian/Grid>.
     * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
     *         If not on zero of other axis, return null/undefined.
     *         If no axes, return an empty array.
     */

/**
     * Axis model
     * @param {module:echarts/coord/cartesian/AxisModel}
     */

/**
     * Each item cooresponds to this.getExtent(), which
     * means globalExtent[0] may greater than globalExtent[1],
     * unless `asc` is input.
     *
     * @param {boolean} [asc]
     * @return {Array.<number>}
     */

/**
     * Transform global coord to local coord,
     * i.e. var localCoord = axis.toLocalCoord(80);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */

/**
     * Transform global coord to local coord,
     * i.e. var globalCoord = axis.toLocalCoord(40);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */

// Inverse the axis.

// Axis name displayed.

// 'start' | 'middle' | 'end'

// By degree. By defualt auto rotate by nameLocation.

// Use global text style by default.

// The gap between axisName and axisLine.

// Default `false` to support tooltip.

// Default `false` to avoid legacy user event listener fail.

// The arrow at both ends the the axis.

// Whether axisTick is inside the grid or outside the grid.

// The length of axisTick.

// Whether axisLabel is inside the grid or outside the grid.

// true | false | null/undefined (auto)

// formatter: null,

// The gap at both ends of the axis. For categoryAxis, boolean.

// Set false to faster category collection.

// Only usefull in the case like: category is

// ['2012-01-01', '2012-01-02', ...], where the input

// null means "auto":

// if axis.data provided, do not deduplication,

// else do deduplication.

// splitArea: {

// show: false

// If tick is align with label when boundaryGap is true

// The gap at both ends of the axis. For value axis, [GAP, GAP], where

// `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)

// min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]

// Min value of the axis. can be:

// + a number

// + 'dataMin': use the min value in data.

// + null/undefined: auto decide min value (consider pretty look and boundaryGap).

// min: null,

// Max value of the axis. can be:

// + 'dataMax': use the max value in data.

// + null/undefined: auto decide max value (consider pretty look and boundaryGap).

// max: null,

// Readonly prop, specifies start value of the range when using data zoom.

// rangeStart: null

// Readonly prop, specifies end value of the range when using data zoom.

// rangeEnd: null

// Optional value can be:

// + `false`: always include value 0.

// + `true`: the extent do not consider value 0.

// scale: false,

// AxisTick and axisLabel and splitLine are caculated based on splitNumber.

/**
             * @readOnly
             */

/**
             * @override
             */

/**
             * Should not be called before all of 'getInitailData' finished.
             * Because categories are collected during initializing data.
             */

// warning if called before all of 'getInitailData' finished.

// FIXME axisType is fixed ?

/**
     * @type {module:echarts/coord/cartesian/Axis2D}
     */

/**
     * @override
     * @return {module:echarts/model/Component}
     */

/**
 * Generate sub axis model class
 * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
 * @param {module:echarts/model/Component} BaseAxisModelClass
 * @param {Function} axisTypeDefaulter
 * @param {Object} [extraDefaultOption]
 */

// Default axis with data is category axis

// gridIndex: 0,

// gridId: '',

// Offset is for multiple axis on the same position

/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */

// Depends on GridModel, AxisModel, which performs preprocess.

/**
 * Check if the axis is used in the specified grid
 * @inner
 */

/**
     * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
     * @private
     */

/**
     * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
     * @private
     */

/**
     * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
     * @private
     */

/**
     * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
     * @private
     */

// Grid 是在有直角坐标系的时候必须要存在的

// 所以这里也要被 Cartesian2D 依赖

/**
     * @type {module:echarts/coord/cartesian/Grid}
     */

// If grid size contain label

// width: {totalWidth} - left - right,

// height: {totalHeight} - top - bottom,

// TODO: onZero of multiple axes.

// onZero can not be enabled in these two situations:

// 1. When any other axis is a category axis.

// 2. When no axis is cross 0 point.

// If target axis is specified.

// Find the first available other axis.

/**
 * Resize the grid
 * @param {module:echarts/coord/cartesian/GridModel} gridModel
 * @param {module:echarts/ExtensionAPI} api
 */

// Key: axisDim_axisIndex, value: boolean, whether onZero target.

// Resize again if containLabel is enabled

// FIXME It may cause getting wrong grid size in data processing stage

// Fast transform

// Minus label size

// Optimize for large category data, avoid call `getTicks()`.

// Simple optimization for large amount of labels

/**
 * @param {string} axisType
 * @param {number} [axisIndex]
 */

// Find first axis

/**
 * @return {Array.<module:echarts/coord/Axis>}
 */

/**
 * Usage:
 *      grid.getCartesian(xAxisIndex, yAxisIndex);
 *      grid.getCartesian(xAxisIndex);
 *      grid.getCartesian(null, yAxisIndex);
 *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
 *
 * @param {number|Object} [xAxisIndex]
 * @param {number} [yAxisIndex]
 */

// When only xAxisIndex or yAxisIndex given, find its first cartesian.

/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */

/**
 * Initialize cartesian coordinate systems
 * @private
 */

/// Create axis

// Roll back when there no either x or y axis

// Fix position

// Default bottom of X

// Default left of Y

// Inject axisModel into axis

// Inject axis into axisModel

// Inject grid info axis

// Index of axis, can be used as key

/// Create cartesian2d

/**
 * Update cartesian properties from series
 * @param  {module:echarts/model/Option} option
 * @private
 */

// For example, the extent of the orginal dimension

// is [0.1, 0.5], the extent of the `stackResultDimension`

// is [7, 9], the final extent should not include [0.1, 0.5].

// Reset scale

/**
 * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
 * @return {Object} {baseAxes: [], otherAxes: []}
 */

// dataSampling requires axis extent, so resize

// should be performed in create stage.

// Inject the coordinateSystems into seriesModel

// For deciding which dimensions to use when creating list data

/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 *
 * @param {module:zrender/container/Group} group
 * @param {Object} axisModel
 * @param {Object} opt Standard axis parameters.
 * @param {Array.<number>} opt.position [x, y]
 * @param {number} opt.rotation by radian
 * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
 * @param {number} [opt.tickDirection=1] 1 or -1
 * @param {number} [opt.labelDirection=1] 1 or -1
 * @param {number} [opt.labelOffset=0] Usefull when onZero.
 * @param {string} [opt.axisLabelShow] default get from axisModel.
 * @param {string} [opt.axisName] default get from axisModel.
 * @param {number} [opt.axisNameAvailableWidth]
 * @param {number} [opt.labelRotate] by degree, default get from axisModel.
 * @param {number} [opt.strokeContainThreshold] Default label interval when label
 * @param {number} [opt.nameTruncateMaxWidth]
 */

// Default value

// FIXME Not use a seperate text group?

// this.group.add(dumbGroup);

// this._dumbGroup = dumbGroup;

// Id for animation

// Use the same arrow for start and end point

// Use the same size for width and height

// Calculate arrow position with offset

// Tick line, Not use group transform to have better line draw

// If min or max are user set, we need to check

// If the tick on min(max) are overlap on their neighbour tick

// If they are overlapped, we need to hide the min(max) tick label

// Have not consider onBand yet, where tick els is more than label els.

// (1) In category axis with data zoom, tick is not the original

// (2) Compatible with previous version, which always use formatted label as

// input. But in interval scale the formatted label is like '223,445', which

// maked user repalce ','. So we modify it to return original val but remain

// it as 'string' to avoid error in replacing.

// Pack data for mouse event

// 'middle'

// Reuse labelOffset.

// Adapt to axis.

// Label is parallel with axis line.

// Label is inverse parallel with axis line.

/**
 * @public
 * @static
 * @param {Object} opt
 * @param {number} axisRotation in radian
 * @param {number} textRotation in radian
 * @param {number} direction
 * @return {Object} {
 *  rotation, // according to axis
 *  textAlign,
 *  textVerticalAlign
 * }
 */

// current and next has the same rotation.

// When checking intersect of two rotated labels, we use mRotationBack

// to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.

// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.

// allAxesInfo should be updated when setOption performed.

/**
         * key: makeKey(axis.model)
         * value: {
         *      axis,
         *      coordSys,
         *      axisPointerModel,
         *      triggerTooltip,
         *      involveSeries,
         *      snap,
         *      seriesModels,
         *      seriesDataCount
         * }
         */

/**
         * key: makeKey(coordSys.model)
         * value: Object: key makeKey(axis.model), value: axisInfo
         */

// Collect axes info.

// Some coordinate system do not support axes, like geo.

// If axis tooltip used, choose tooltip axis for each coordSys.

// Notice this case: coordSys is `grid` but not `cartesian2D` here.

// Compatible with previous logic. But series.tooltip.trigger: 'axis'

// or series.data[n].tooltip.trigger: 'axis' are not support any more.

// fromTooltip: true | false | 'cross'

// triggerTooltip: true | false | null

// Compatibel with previous behavior, tooltip axis do not show label by default.

// Only these properties can be overrided from tooltip to axisPointer.

// category axis do not auto snap, otherwise some tick that do not

// has value can not be hovered. value/time/log axis default snap if

// triggered from tooltip and trigger tooltip.

// Follow the convention, do not show label when triggered by tooltip by default.

// When 'cross', both axes show labels.

// If triggerTooltip, this is a base axis, which should better not use cross style

// (cross style is dashed by default)

/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */

// Check seriesInvolved for performance, in case too many series in some chart.

// Prepare data for axis trigger

// Notice this case: this coordSys is `cartesian2D` but not `grid`.

/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */

/**
 * Base class of AxisView.
 */

/**
     * @protected
     * @type {string}
     */

// This process should proformed after coordinate systems updated

// (axis scale updated), and should be performed each time update.

// So put it here temporarily, although it is not appropriate to

// put a model-writing procedure in `view`.

// Parse init value for category and time axis.

// If `handle` used, `axisPointer` will always be displayed, so value

// and status should be initialized.

// Pick a value on axis when initializing.

// Make handle displayed on the end of the axis when init, which looks better.

/**
     * Action handler.
     * @public
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/model/Global} ecModel
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} payload
     */

/**
 * Can only be called after coordinate system creation stage.
 * (Can be called before coordinate system update stage).
 *
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, z2
 * }
 */

// Axis position

// Axis rotation

// Special label rotation

// Over splitLine and splitArea

/**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */

// For Making appropriate splitArea animation, the color and anid

// should be corresponding to previous one if possible.

// Grid view

// Only create grid when need

// In case developer forget to include grid component

// Down sample after filter

// Only cartesian2d support down sampling

// Only support sample the first dim mapped from value axis.

// PENDING if clamp ?

// 一级层叠

// 二级层叠

// Cartesian coordinate system

// 最小高度改为0

// 最小角度为0，仅对极坐标系下的柱状图有效

// barMaxWidth: null,

// 默认自适应

// barWidth: null,

// 柱间距离，默认为柱形宽度的30%，可设固定值

// barGap: '30%',

// 类目间柱形距离，默认为类目间距的20%，可设固定值

// barCategoryGap: '20%',

// label: {

//      show: false

// Do not support progressive in normal mode.

// Compatitable with 2

// Just for compatible with ec2.

// Animation

// Keep the same logic with bar in catesion: use end value to control

// direction. Notice that if clockwise is true (by default), the sector

// will always draw clockwisely, no matter whether endAngle is greater

// or less than startAngle.

// In case width or height are too small.

// Drawing lines is more efficient than drawing

// a whole line or drawing rects.

// TODO support polar

/*, baseDim*/

// Because of the barMinHeight, we can not use the value in

// stackResultDimension directly.

// Only ordinal axis can be stacked.

// Should also consider #4243

// Include zero to has a positive bar

// Should after normal bar layout, otherwise it is blocked by normal bar layout.

// Visual coding for legend

/**
 * [Usage]:
 * (1)
 * createListSimply(seriesModel, ['value']);
 * (2)
 * createListSimply(seriesModel, {
 *     coordDimensions: ['value'],
 *     dimensionsCount: 5
 * });
 *
 * @param {module:echarts/model/Series} seriesModel
 * @param {Object|Array.<string|Object>} opt opt or coordDimensions
 *        The options in opt, see `echarts/data/helper/createDimensions`
 * @param {Array.<string>} [nameList]
 * @return {module:echarts/data/List}
 */

/**
     * @param {Array.<Object>} targetList [{name, value, selected}, ...]
     *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
     *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
     */

/**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */

// PENGING If selectedMode is null ?

// var selectedMode = this.get('selectedMode');

// selectedMode !== 'single' && target && (target.selected = false);

// Overwrite

// Enable legend selection for each data item

// Use a function instead of direct access because data reference may changed

// Extend labelLine emphasis

// Not show label line if `label.normal.show = false`

// 默认全局居中

// 默认顺时针

// 最小角度改为0

// 选中时扇区偏移量

// 高亮扇区偏移量

// If use strategy to avoid label overlapping

// 选择模式，默认关闭，可选single，multiple

// selectedMode: false,

// 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）

// roseType: null,

// If still show when all data zero.

// If rotate around circle

// 'outer', 'inside', 'center'

// Enabled when label.normal.position is 'outer'

// 引导线两段中的第一段长度

// 引导线两段中的第二段长度

// color: 各异,

// Animation type canbe expansion, scale

/**
 * Data selectable mixin for chart series.
 * To eanble data select, option of series must have `selectedMode`.
 * And each data item will use `selected` to toggle itself selected status
 */

/**
 * @param {module:echarts/model/Series} seriesModel
 * @param {boolean} hasAnimation
 * @inner
 */

/**
 * @param {module:zrender/graphic/Sector} el
 * @param {Object} layout
 * @param {boolean} isSelected
 * @param {number} selectedOffset
 * @param {boolean} hasAnimation
 * @inner
 */

/**
 * Piece of pie including Sector, Label, LabelLine
 * @constructor
 * @extends {module:zrender/graphic/Group}
 */

// Hover to change label and labelLine

// Update common style

// Sector may has animation of updating data. Force to move to the last frame

// Or it may stopped on the wrong shape

// Toggle selected

// Default use item visual color

// Pie view

// Default expansion animation

// clipPath is used in first-time animation, so remove it when otherwise. See: #8994

/**
     * @implement
     */

// FIXME emphasis label position is not same with normal label position

// up

// right-down, left-down

// right-up, left-up

// Not change x for center label

// For roseType

// Not layout the inside label

/**
         * @payload
         * @property {string} seriesName
         * @property {string} name
         */

// Create selected map

// Pie and funnel may use diferrent scope

// If series.itemStyle.normal.color is a function. itemVisual may be encoded

// Set data all color for legend

// FIXME Performance

// Legend may use the visual info in data before processed

// Data is not filtered

// Sum may be 0

// In the case some sector angle is smaller than minAngle

// Some sector is constrained by minAngle

// Rest sectors needs recalculate angle

// FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？

// Average the angle if rest angle is not enough after all angles is

// Constrained by minAngle

// If in any legend component the status is not selected.

// Polar coordinate system

// Geo coordinate system

// geoIndex: 0,

// symbol: null,        // 图形类型

// 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2

// symbolRotate: null,  // 图形旋转控制

// Available when large is true

// distance: 5,

// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调

// position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为

//           'inside'|'left'|'right'|'top'|'bottom'

// 默认使用全局文本样式，详见TEXTSTYLE

// TODO Batch by color

// Do draw in afterBrush.

// PENDING If style or other canvas status changed?

// fillRect is faster than building a rect path and draw.

// And it support light globalCompositeOperation.

// Not consider transform

// Treat each element as a rect

// top down traverse

// TODO ???

// Consider transform

/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 */

// Only use incremental displayables when data amount is larger than 2 million.

// PENDING Incremental data?

// if (data.hasItemVisual.symbolSize) {

//     // TODO typed array?

//     symbolEl.setShape('sizes', data.mapArray(

//         function (idx) {

//             var size = data.getItemVisual(idx, 'symbolSize');

//             return (size instanceof Array) ? size : [size, size];

//     ));

// Create symbolProxy to build path for each data

// Use symbolProxy setColor method

// Draw shadow when doing fillRect is extremely slow.

// Enable tooltip

// PENDING May have performance issue when path is extremely large

// Provide dataIndex for tooltip

// Must mark group dirty and make sure the incremental layer will be cleared

// import * as zrUtil from 'zrender/src/core/util';

// echarts.registerProcessor(function (ecModel, api) {

//     ecModel.eachSeriesByType('scatter', function (seriesModel) {

//         var data = seriesModel.getData();

//         var coordSys = seriesModel.coordinateSystem;

//         if (coordSys.type !== 'geo') {

//             return;

//         var startPt = coordSys.pointToData([0, 0]);

//         var endPt = coordSys.pointToData([api.getWidth(), api.getHeight()]);

//         var dims = zrUtil.map(coordSys.dimensions, function (dim) {

//             return data.mapDimension(dim);

//         var range = {};

//         range[dims[0]] = [Math.min(startPt[0], endPt[0]), Math.max(startPt[0], endPt[0])];

//         range[dims[1]] = [Math.min(startPt[1], endPt[1]), Math.max(startPt[1], endPt[1])];

//         data.selectRange(range);

// -------------

// Preprocessor

// Convert

// {graphic: [{left: 10, type: 'circle'}, ...]}

// or

// {graphic: {left: 10, type: 'circle'}}

// to

// {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}

// Only one graphic instance can be instantiated. (We dont

// want that too many views are created in echarts._viewMap)

// ------

// Model

// Extra properties for each elements:

// left/right/top/bottom: (like 12, '22%', 'center', default undefined)

//      If left/rigth is set, shape.x/shape.cx/position will not be used.

//      If top/bottom is set, shape.y/shape.cy/position will not be used.

//      This mechanism is useful when you want to position a group/element

//      against the right side or the center of this container.

// width/height: (can only be pixel value, default 0)

//      Only be used to specify contianer(group) size, if needed. And

//      can not be percentage value (like '33%'). See the reason in the

//      layout algorithm below.

// bounding: (enum: 'all' (default) | 'raw')

//      Specify how to calculate boundingRect when locating.

//      'all': Get uioned and transformed boundingRect

//          from both itself and its descendants.

//          This mode simplies confining a group of elements in the bounding

//          of their ancester container (e.g., using 'right: 0').

//      'raw': Only use the boundingRect of itself and before transformed.

//          This mode is similar to css behavior, which is useful when you

//          want an element to be able to overflow its container. (Consider

//          a rotated circle needs to be located in a corner.)

// info: custom info. enables user to mount some info on elements and use them

//      in event handlers. Update them only when user specified, otherwise, remain.

// Note: elements is always behind its ancestors in this elements array.

/**
     * Save el options for the sake of the performance (only update modified graphics).
     * The order is the same as those in option. (ancesters -> descendants)
     *
     * @private
     * @type {Array.<Object>}
     */

// Prevent default merge to elements

// Clear elOptionsToUpdate

// Set id and type after id assigned.

// Set parent id if not specified

// Update existing options, for `getOption` feature.

// We can ensure that newElOptCopy and existElOption are not

// the same object, so `merge` will not change newElOptCopy.

// Rigid body, use ignoreSize.

// Will be used in render.

// null will be cleaned later.

// Give default group size. Otherwise layout error may occur.

// Rigid body, dont care `width`.

// Rigid body, dont care `height`.

// Clean

// $action should be volatile, otherwise option gotten from

// `getOption` will contain unexpected $action.

/**
     * Convert
     * [{
     *  type: 'group',
     *  id: 'xx',
     *  children: [{type: 'circle'}, {type: 'polygon'}]
     * }]
     * to
     * [
     *  {type: 'group', id: 'xx'},
     *  {type: 'circle', parentId: 'xx'},
     *  {type: 'polygon', parentId: 'xx'}
     * ]
     *
     * @private
     * @param {Array.<Object>} optionList option list
     * @param {Array.<Object>} result result of flatten
     * @param {Object} parentOption parent option
     */

// Deleting for JSON output, and for not affecting group creation.

// Pass to view using payload? setOption has a payload?

// Clear to avoid render duplicately when zooming.

// -----

// View

// Remove unnecessary props to avoid potential problems.

/**
         * @private
         * @type {module:zrender/core/util.HashMap}
         */

/**
         * @private
         * @type {module:echarts/graphic/GraphicModel}
         */

// Having leveraged between use cases and algorithm complexity, a very

// simple layout mechanism is used:

// The size(width/height) can be determined by itself or its parent (not

// implemented yet), but can not by its children. (Top-down travel)

// The location(x/y) can be determined by the bounding rect of itself

// (can including its descendants or not) and the size of its parent.

// (Bottom-up travel)

// When `chart.clear()` or `chart.setOption({...}, true)` with the same id,

// view will be reused.

/**
     * Update graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     */

// Top-down tranverse to assign graphic settings to each elements.

// In top/bottom mode, textVerticalAlign should not be used, which cause

// inaccurately locating.

// Compatible with previous setting: both support fill and textFill,

// stroke and textStroke.

// For simple, do not support parent change, otherwise reorder is needed.

// Simple optimize for large amount of elements that no need event.

// `elOption.info` enables user to mount some info on

// elements and use them in event handlers.

/**
 * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} {point: [x, y], el: ...} point Will not be null.
 */

/**
     * Locate graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     * @param {module:echarts/ExtensionAPI} api extension API
     */

// Bottom-up tranvese all elements (consider ec resize) to locate elements.

// Like 'position:absolut' in css, default 0.

/**
     * Clear all elements.
     *
     * @private
     */

// Use graphic bounding rect

// Heavy calculation. So put it after axis.containData checking.

// Add a threshold to avoid find the wrong dataIndex

// when data length is not same.

// false,

// Consider category case

// Fill content of event obj for echarts.connect.

// By defualt use the first involved series data as a sample to connect.

// If no linkSource input, this process is for collecting link

// target, where snap should not be accepted.

// Tooltip should always be snapToValue, otherwise there will be

// incorrect "axis value ~ series value" mapping displayed in tooltip.

// If no data, do not create anything in dataByCoordSys,

// whose length will be used to judge whether dispatch action.

// Caustion: viewHelper.getValueLabel is actually on "view stage", which

// depends that all models have been updated. So it should not be performed

// here. Considering axisPointerModel used here is volatile, which is hard

// to be retrieve in TooltipView, we prepare parameters here.

// 'auto' means that show when triggered by tooltip or handle.

// 'click' | 'mousemove' | 'none'

// set default in AxisPonterView.js

// 'line' 'shadow' 'cross' 'none'.

// axispointer triggered by tootip determine snap automatically,

// see `modelHelper`.

// Init value depends on whether handle is used.

// [group0, group1, ...]

// Each group can be: {

//      mapper: function () {},

//      singleTooltip: 'multiple',  // 'multiple' or 'single'

//      xAxisId: ...,

//      yAxisName: ...,

//      angleAxisIndex: ...

// mapper: can be ignored.

//      input: {axisInfo, value}

//      output: {axisInfo, value}

// Do not set 'auto' here, otherwise global animation: false

// will not effect at this axispointer.

// string | Function

// Or a number like 0, 1, 2 ...

// default: axis line color

// handle margin is from symbol center to axis, which is stable when circular move.

// color: '#1b8bbd'

// color: '#2f4554'

// For mobile performance

/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

// better approach?

// 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,

// which may be conflict, (axisPointer call showTip but tooltip call hideTip);

// So we have to add "final stage" to merge those dispatched actions.

/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 */

// useHandler('mouseout', onLeave);

// Register global listener in AxisPointerView to enable

// AxisPointerView to be independent to Tooltip.

// If 'none', it is not controlled by mouse totally.

/**
 * Base axis pointer class in 2D.
 * Implemenents {module:echarts/component/axis/IAxisPointer}.
 */

// Animation optimize.

/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */

// Not overflow ec container

// Do not overflow ec container

/**
 * @param {number} value
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} opt
 * @param {Array.<Object>} seriesDataIndices
 * @param {number|string} opt.precision 'auto' or a number
 * @param {string|Function} opt.formatter label formatter
 */

// TODO: rich

// Lable should be over axisPointer.

// If `precision` is set, width can be fixed (like '12.00500'), which

// helps to debounce when when moving label.

/**
 * @param {module:echarts/coord/Axis} axis
 * @param {number} value
 * @param {Object} layoutInfo {
 *  rotation, position, labelOffset, labelDirection, labelMargin
 * }
 */

/**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     * @protected
     */

// Optimize: `render` will be called repeatly during mouse move.

// So it is power consuming if performing `render` each time,

// especially on mobile device.

// Bind them to `this`, not in closure, otherwise they will not

// be replaced when user calling setOption in not merge mode.

// Do not clear here, for animation better.

// Otherwise status is 'show'

// Enable change axis pointer type.

// Value axis without snap always do not snap.

// It is important to auto animation when snap used. Consider if there is

// a dataZoom, animation will be disabled when too many points exist, while

// it will be enabled for better visual effect when little points exist.

// Approximate band width

/**
     * add {pointer, label, graphicKey} to elOption
     * @protected
     */

// Shoule be implemenented by sub-class.

// Consider text length change in vertical axis, animation should

// be used on shape, otherwise the effect will be weird.

// Fot mobile devicem, prevent screen slider on the button.

// update position

// Persistent for throttle.

/**
     * Throttled method.
     * @private
     */

// Consider snap or categroy axis, handle may be not consistent with

// axisPointer. So move handle to align the exact value position when

// drag ended.

// For the effect: tooltip will be shown when finger holding on handle

// button, and will be hidden after finger left handle button.

/**
     * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {number} value
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0}
     */

/**
     * * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {Object} transform {position, rotation}
     * @param {Array.<number>} delta [dx, dy]
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
     */

// Implemented by sub-class if necessary.

/**
     * @protected
     * @param {Array.<number>} xy
     * @param {Array.<number>} wh
     * @param {number} [xDimIndex=0] or 1
     */

/**
 * @param {module:echarts/model/Model} axisPointerModel
 */

/**
 * @param {Array.<number>} p1
 * @param {Array.<number>} p2
 * @param {number} [xDimIndex=0] or 1
 */

/**
 * @param {Array.<number>} xy
 * @param {Array.<number>} wh
 * @param {number} [xDimIndex=0] or 1
 */

// CartesianAxisPointer is not supposed to be required here. But consider

// echarts.simple.js and online build tooltip, which only require gridSimple,

// CartesianAxisPointer should be able to required somewhere.

// Always has a global axisPointerModel for default setting.

// Normalize to array to avoid object mergin. But if link

// is not set, remain null/undefined, otherwise it will

// override existent link setting.

// This process should proformed after coordinate systems created

// and series data processed. So put it on statistic processing stage.

// Broadcast to all views.

// See #6121. But we are not able to reproduce it yet.

// Used in the default behavior of `connection`: use the sample seriesIndex

// and dataIndex. And also used in the tooltipView trigger.

// Do not use dataIndexInside from other ec instance.

// FIXME: auto detect it?

// Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).

// Notice: In this case, it is difficult to get the `point` (which is necessary to show

// tooltip, so if point is not given, we just use the point found by sample seriesIndex

// and dataIndex.

// Process for triggered axes.

// If a point given, it must be contained by the coordinate system.

// If no inputAxesInfo, no axis is restricted.

// Process for linked axes.

// If axis has been triggered in the previous stage, it should not be triggered by link.

// If srcValItem exist, source axis is triggered, so link to target axis.

// Basic logic: If no 'show' required, 'hide' this axisPointer.

// For label formatter param and highlight.

// If hide, value still need to be set, consider

// click legend to toggle axis blank.

// If status is 'hide', should be no info in payload.

// Basic logic: If no showTip required, hideTip will be dispatched.

// In most case only one axis (or event one series is used). It is

// convinient to fetch payload.seriesIndex and payload.dataIndex

// dirtectly. So put the first seriesIndex and dataIndex of the first

// axis on the payload.

// highlight status modification shoule be a stage of main process?

// (Consider confilct (e.g., legend and axisPointer) and setOption)

// Update highlight/downplay status according to axisPointer model.

// Build hash map and remove duplicate incidentally.

// Diff.

// tooltip主体内容

// 'trigger' only works on coordinate system.

// 'item' | 'axis' | 'none'

// 'single' | 'multipleByCoordSys'

// 'auto' | 'html' | 'richText'

// 'auto': use html by default, and use non-html if `document` is not defined

// 'html': use html for tooltip

// 'richText': use canvas, svg, and etc. for tooltip

// 位置 {Array} | {Function}

// position: null

// Consider triggered from axisPointer handle, verticalAlign should be 'middle'

// align: null,

// verticalAlign: null,

// 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。

// 内容格式器：{string}（Template） ¦ {Function}

// formatter: null

// 隐藏延迟，单位ms

// 动画变换时间，单位s

// 提示背景颜色，默认为透明度为0.7的黑色

// 提示边框颜色

// 提示边框圆角，单位px，默认为4

// 提示边框线宽，单位px，默认为0（无边框）

// 提示内边距，单位px，默认各方向内边距为5，

// 接受数组分别设定上右下左边距，同css

// Extra css text

// 坐标轴指示器，坐标轴触发有效

// 默认为直线

// 可选为：'line' | 'shadow' | 'cross'

// type 为 line 的时候有效，指定 tooltip line 所在的轴，可选

// 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'

// 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴

// 极坐标系会默认选择 angle 轴

// TODO formatter

/**
 * @param {Object} tooltipModel
 * @return {string}
 * @inner
 */

// Animation transition. Do not animate when transitionDuration is 0.

/**
 * @param {number} duration
 * @return {string}
 * @inner
 */

/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */

// for ie

// Border style

// Text style

// Padding

/**
 * @alias module:echarts/component/tooltip/TooltipContent
 * @constructor
 */

// clear the timeout in hideLater and keep showing tooltip

// Try trigger zrender event to avoid mouse

// in and out shape too frequently

// import Group from 'zrender/src/container/Group';

/**
 * @alias module:echarts/component/tooltip/TooltipRichContent
 * @constructor
 */

/**
     * Update when tooltip is rendered
     */

// Move this logic to ec main?

// Hide the tooltip

// this.hide();

// If mouse occsionally move over the tooltip, a mouseout event will be

// triggered by canvas, and cuase some unexpectable result like dragging

// stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve

// it. Although it is not suppored by IE8~IE10, fortunately it is a rare

// scenario.

// xy should be based on canvas root. But tooltipContent is

// the sibling of canvas root. So padding of ec container

// should be considered here.

// Set show false to avoid invoke hideLater mutiple times

// Consider browser compatibility.

// IE8 does not support getComputedStyle.

// noop

/**
     * Set tooltip content
     *
     * @param {string} content rich text string of content
     * @param {Object} markerRich rich text style
     * @param {Object} tooltipModel tooltip model
     */

// TODO: textOffset is not implemented for rich text

/**
 * @param {Array.<Object|module:echarts/model/Model>} modelCascade
 * From top to bottom. (the last one should be globalTooltipModel);
 */

// In each data item tooltip can be simply write:

//  value: 10,

//  tooltip: 'Something you need to know'

// FIXME Better way to pack data in graphic element

/**
 * @action
 * @property {string} type
 * @property {number} seriesIndex
 * @property {number} dataIndex
 * @property {number} [x]
 * @property {number} [y]
 */

/**
         * @private
         * @type {module:echarts/component/tooltip/TooltipModel}
         */

/**
         * @private
         * @type {module:echarts/model/Global}
         */

/**
         * @private
         * @type {module:echarts/ExtensionAPI}
         */

/**
         * Should be cleaned when render.
         * @private
         * @type {Array.<Array.<Object>>}
         */

/**
         * @private
         * @type {boolean}
         */

// Try to keep the tooltip show when refreshing

// Show tip next tick after other charts are rendered

// In case highlight action has wrong result

/**
     * Show tip manually by
     * dispatchAction({
     *     type: 'showTip',
     *     x: 10,
     *     y: 10
     * });
     * Or
     * dispatchAction({
     *      type: 'showTip',
     *      seriesIndex: 0,
     *      dataIndex or dataIndexInside or name
     * });
     *
     *  TODO Batch
     */

// Reset ticket

// When triggered from axisPointer.

// Manually show tooltip while view is not using zrender elements.

// should wrap dispatchAction like `axisPointer/globalListener` ?

// Be compatible with previous design, that is, when tooltip.type is 'axis' and

// dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer

// and tooltip.

// Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed

// showDelay is used in this case: tooltip.enterable is set

// as true. User intent to move mouse into tooltip and click

// something. `showDelay` makes it easyer to enter the content

// but tooltip do not move immediately.

// var coordParamList = [];

// var coordDefaultHTML = [];

// var coordTooltipModel = buildTooltipModel([

//     e.tooltipOption,

//     itemCoordSys.tooltipOption,

//     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),

//     globalTooltipModel

// var displayMode = coordTooltipModel.get('displayMode');

// var paramsList = displayMode === 'single' ? singleParamsList : [];

// Default tooltip content

// (1) shold be the first data which has name?

// (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

// In most case, the second axis is shown upper than the first one.

// Use dataModel in element if possible

// Used when mouseover on a element like markPoint or edge

// In which case, the data is not main data in series.

// duplicated showtip if manuallyShowTip is called from dispatchAction.

// Fixed formatter

// Do not check whether `trigger` is 'none' here, because `trigger`

// only works on cooridinate system. In fact, we have not found case

// that requires setting `trigger` nothing on component yet.

// If not dispatch showTip, tip may be hide triggered by axis.

/**
     * @param  {string|Function|Array.<number>|Object} positionExpr
     * @param  {number} x Mouse x
     * @param  {number} y Mouse y
     * @param  {boolean} confine Whether confine tooltip content in view rect.
     * @param  {Object|<Array.<Object>} params
     * @param  {module:zrender/Element} el target element
     * @param  {module:echarts/ExtensionAPI} api
     * @return {Array.<number>}
     */

// Callback of position can be an array or a string specify the position

// When positionExpr is left/top/right/bottom,

// align and verticalAlign will not work.

// Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element

// Should we remove this but leave this to user?

// Do not directly hideLater here, because this behavior may be prevented

// in dispatchAction when showTip is dispatched.

// duplicated hideTip if manuallyHideTip is called from dispatchAction.

// legend.width/height are maxWidth/maxHeight actually,

// whereas realy width/height is calculated by its content.

// (Setting {left: 10, right: 10} does not make sense).

// So consider the case:

// `setOption({legend: {left: 10});`

// then `setOption({legend: {right: 10});`

// The previous `left` should be cleared by setting `ignoreSize`.

// If selectedMode is single, try to select one

// If has any selected in option.selected

// Force to unselect others

// Try select the first if selectedMode is single

/**
         * @type {Array.<string>}
         * @private
         */

// If legend.data not specified in option, use availableNames as data,

// which is convinient for user preparing option.

// Can be string or number

/**
         * @type {Array.<module:echarts/model/Model>}
         * @private
         */

/**
     * @return {Array.<module:echarts/model/Model>}
     */

/**
     * @param {string} name
     */

// Default is true

// 布局方式，默认为水平布局，可选为：

// 'horizontal' | 'vertical'

// right: 'center',

// bottom: null,

// 水平对齐

// 'auto' | 'left' | 'right'

// 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐

// 图例边框颜色

// 图例边框线宽，单位px，默认为0（无边框）

// 图例内边距，单位px，默认各方向内边距为5，

// 各个item之间的间隔，单位px，默认为10，

// 横向布局时为水平间隔，纵向布局时为纵向间隔

// 图例图形宽度

// 图例图形高度

// 图例关闭时候的颜色

// 图例文字颜色

// formatter: '',

// 选择模式，默认开启图例开关

// 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入

// selected: null,

// 图例内容（详见legend.data，数组中每一项代表一个item

// data: [],

// Tooltip 相关配置

// Return the event explicitly

// Update all legend components

// Force other legend has same selected status

// Or the first is toggled to true and other are toggled to false

// In the case one legend has some item unSelected in option. And if other legend

// doesn't has the item, they will assume it is selected.

// Wrap element

// Unselected if any legend is unselected

/**
 * @event legendToggleSelect
 * @type {Object}
 * @property {string} type 'legendToggleSelect'
 * @property {string} [from]
 * @property {string} name Series name or data item name
 */

// `subPixelOptimizeRect` may bring some gap between edge of viewpart

// and background rect when setting like `left: 0`, `top: 0`.

// graphic.subPixelOptimizeRect(rect);

/**
 * @event legendSelect
 * @type {Object}
 * @property {string} type 'legendSelect'
 * @property {string} name Series name or data item name
 */

/**
 * @event legendUnSelect
 * @type {Object}
 * @property {string} type 'legendUnSelect'
 * @property {string} name Series name or data item name
 */

/**
         * @private
         * @type {module:zrender/container/Group}
         */

/**
         * @private
         * @type {module:zrender/Element}
         */

/**
         * If first rendering, `contentGroup.position` is [0, 0], which
         * does not make sense and may cause unexepcted animation if adopted.
         * @private
         * @type {boolean}
         */

// Perform layout.

// Render background after group is layout.

// Use empty string or \n as a newline string

// Representitive series.

// Series legend

// If color is a callback function

// Use the first data

// Using rect symbol defaultly

// Data legend of pie, funnel

// In case multiple series has same data name

// FIXME: consider different series has items with the same name.

// Compose symbols

// Use user given icon first

// symbolKeepAspect default true for legend

// Put symbol in the center

// Add a invisible rect to increase the area of mouse hover

// Defaul formatter

// Place items in contentGroup.

// If element hover will move to a hoverLayer.

// Do not contain scrollable legend, for sake of file size.

// Series Filter

// Because in legend series is assumed selected when it is not in the legend data.

// Default 'plain' when no type specified.

/**
     * @param {number} scrollDataIndex
     */

// 'start' or 'end'

// If null/undefined, do not show page.

// Can be [10, 3], which represents [width, height]

// Do not `ignoreSize` to enable setting {left: 10, right: 10}.

/**
 * Separate legend and scrollable legend to reduce package size.
 */

/**
         * @private
         * @type {number} For `scroll`.
         */

/**
         *
         * @private
         */

// Render content items.

// FIXME: support be 'auto' adapt to size number text length,

// e.g., '3/12345' should not overlap with the control arrow button.

// Buttons will be created in each render, so we do not need

// to worry about avoiding using legendModel kept in scope.

// Buttons in controller are layout always horizontally.

// Remain contentPos when scroll animation perfroming.

// If first rendering, `contentGroup.position` is [0, 0], which

// does not make sense and may cause unexepcted animation if adopted.

// Layout container group based on 0.

// Place containerGroup and controllerGroup and contentGroup.

// controller is on the right / bottom.

// Always align controller to content as 'middle'.

// Calculate `mainRect` and set `clipPath`.

// mainRect should not be calculated by `this.group.getBoundingRect()`

// for sake of the overflow.

// Consider content may be overflow (should be clipped).

// `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

// Consider content may be larger than container, container rect

// can not be obtained from `containerGroup.getBoundingRect()`.

// Do not remove or ignore controller. Keep them set as place holders.

// Content translate animation.

// When switch from "show controller" to "not show controller", view should be

// updated immediately without animation, otherwise causes weird efffect.

/**
     * @param {module:echarts/model/Model} legendModel
     * @return {Object} {
     *  contentPosition: Array.<number>, null when data item not found.
     *  pageIndex: number, null when data item not found.
     *  pageCount: number, always be a number, can be 0.
     *  pagePrevDataIndex: number, null when no next page.
     *  pageNextDataIndex: number, null when no previous page.
     * }
     */

// Strategy:

// (1) Always align based on the left/top most item.

// (2) It is user-friendly that the last item shown in the

// current window is shown at the begining of next window.

// Otherwise if half of the last item is cut by the window,

// it will have no chance to display entirely.

// (3) Consider that item size probably be different, we

// have calculate pageIndex by size rather than item index,

// and we can not get page index directly by division.

// (4) The window is to narrow to contain more than

// one item, we should make sure that the page can be fliped.

// Half of the last item is out of the window.

// If the current item does not intersect with the window, the new page

// can be started at the current item or the last item.

// If the the end item does not intersect with the window started

// from the current item, a page can be settled.

// e.g., when page size is smaller than item size.

/**
 * @event legendScroll
 * @type {Object}
 * @property {string} type 'legendScroll'
 * @property {string} scrollDataIndex
 */

/**
 * Legend component entry file8
 */

// 超链接跳转

// link: null,

// 仅支持self | blank

// sublink: null,

// 'center' ¦ 'left' ¦ 'right'

// ¦ {number}（x坐标，单位px）

// 'top' ¦ 'bottom' ¦ 'center'

// ¦ {number}（y坐标，单位px）

// 'auto' | 'left' | 'right' | 'center'

// 默认根据 left 的位置判断是左对齐还是右对齐

// textAlign: null

// 垂直对齐

// 'auto' | 'top' | 'bottom' | 'middle'

// 默认根据 top 位置判断是上对齐还是下对齐

// textBaseline: null

// 标题边框颜色

// 标题边框线宽，单位px，默认为0（无边框）

// 标题内边距，单位px，默认各方向内边距为5，

// 主副标题纵向间隔，单位px，默认为10，

// If no subText, but add subTextEl, there will be an empty line.

// Adjust text align based on position

// Align left if title is on the left. center and right is same

// Adjust layout by text align

// Render background

// Get groupRect again because textAlign has been changed

/**
     * @overrite
     */

// Default label emphasis `position` and `show`

// FIXME Overwrite fillLabel method ?

// Use the same series index and name

//symbolRotate: 0,

//symbolOffset: [0, 0]

// Make it simple, do not visit all stacked value to count precision.

// function getPrecision(data, valueAxisDim, dataIndex) {

//     var precision = -1;

//     var stackedDim = data.mapDimension(valueAxisDim);

//     do {

//         precision = Math.max(

//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),

//             precision

//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');

//         if (stackedOnSeries) {

//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);

//             data = stackedOnSeries.getData();

//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);

//             stackedDim = data.getCalculationInfo('stackedDimension');

//             data = null;

//     } while (data);

//     return precision;

/*, otherDataDim*/

/**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */

// TODO Specified percent

/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */

// 1. If not specify the position with pixel directly

// 2. If `coord` is not a data array. Which uses `xAxis`,

// `yAxis` to specify the coord on each dimension

// parseFloat first because item.x and item.y can be percent string like '20%'

// Clone the option

// Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

// Force to use the value of calculated value.

// Each coord support max, min, average

// FIXME Only has one of xAxis and yAxis.

/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {boolean}
 */

// Alwalys return true if there is no coordSys

// x, y, radius, angle

/**
         * Markline grouped by series
         * @private
         * @type {module:zrender/core/util.HashMap}
         */

// Use the getMarkerPoisition

// Use x, y if has any

// updateLayout: function (markPointModel, ecModel, api) {

//     ecModel.eachSeries(function (seriesModel) {

//         var mpModel = seriesModel.markPointModel;

//         if (mpModel) {

//             updateMarkerLayout(mpModel.getData(), seriesModel, api);

//             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);

//     }, this);

/**
 * @inner
 * @param {module:echarts/coord/*} [coordSys]
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */

// In map series data don't have lng and lat dimension. Fallback to same with coordSys

// HINT Markpoint can't be used too much

// FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？

// TODO Text are wrong

// Set host model for tooltip

// Make sure markPoint component is enabled

/**
 * Line path for bezier and straight line draw
 */

/**
 * @module echarts/chart/helper/Line
 */

/**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */

// Update symbol position and rotation

/**
 * @module echarts/chart/helper/LineDraw
 */

// import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';

/**
 * @alias module:echarts/component/marker/LineDraw
 * @constructor
 */

// If line not changed

// FIXME Parent scale changed

// End

// Start

// Use the user specified text align and baseline first

// Temporary solution for `focusNodeAdjacency`.

// line label do not use the opacity of lineStyle.

// symbols must added after line to make sure

// it will be updated after line#update.

// Or symbol position and rotation update in line#beforeUpdate will be one frame slow

// Symbol changed

// Optimization for large dataset

// Update symbol

// FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.

// 'start', 'middle', 'end'

// Only these properties supported in this emphasis style here.

// For merging hover style to normal style, do not use

// `hoverLabelModel.getFont()` here.

/**
 * @param {module:echarts/data/List} lineData
 */

// Do not support update layout in incremental mode.

// Special type markLine like 'min', 'max', 'average', 'median'

// Extra option for tooltip and label

// Avoid line data type is extended by from(to) data type

// Merge from option and to option into line option

// If a markLine has one dim

// In case

//  markLine: {

//    data: [{ yAxis: 2 }]

//  }

// Chart like bar may have there own marker positioning logic

// Expand line to the edge of grid if value on one axis is Inifnity

//    data: [{

//      yAxis: 2

//      // or

//      type: 'average'

//    }]

// updateLayout: function (markLineModel, ecModel, api) {

//         var mlModel = seriesModel.markLineModel;

//         if (mlModel) {

//             var mlData = mlModel.getData();

//             var fromData = mlModel.__from;

//             var toData = mlModel.__to;

//             // Update visual and layout of from symbol and to symbol

//             fromData.each(function (idx) {

//                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);

//                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);

//             });

//             // Update layout of line

//             mlData.each(function (idx) {

//                 mlData.setItemLayout(idx, [

//                     fromData.getItemLayout(idx),

//                     toData.getItemLayout(idx)

//                 ]);

//             this.markerGroupMap.get(seriesModel.id).updateLayout();

// Update visual and layout of from symbol and to symbol

// Update layout of line

/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */

// Line data for tooltip and formatter

// Update visual and layout of line

// Make sure markLine component is enabled

// markArea should fixed on the coordinate system

// color and borderColor default to use color from series

// color: 'auto'

// borderColor: 'auto'

// Merge option into one

// If a markArea has one dim

// dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']

// updateLayout: function (markAreaModel, ecModel, api) {

//         var maModel = seriesModel.markAreaModel;

//         if (maModel) {

//             var areaData = maModel.getData();

//             areaData.each(function (idx) {

//                 var points = zrUtil.map(dimPermutations, function (dim) {

//                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);

//                 });

//                 // Layout

//                 areaData.setItemLayout(idx, points);

//                 var el = areaData.getItemGraphicEl(idx);

//                 el.setShape('points', points);

// Layout

// Visual

// Make sure markArea component is enabled

// Default 'slider' when no type specified.

// Supported coords.

/**
 * Iterate each dimension name.
 *
 * @public
 * @param {Function} callback The parameter is like:
 *                            {
 *                                name: 'angle',
 *                                capital: 'Angle',
 *                                axis: 'angleAxis',
 *                                axisIndex: 'angleAixs',
 *                                index: 'angleIndex'
 *                            }
 * @param {Object} context
 */

/**
 * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * dataZoomModels and 'links' make up one or more graphics.
 * This function finds the graphic where the source dataZoomModel is in.
 *
 * @public
 * @param {Function} forEachNode Node iterator.
 * @param {Function} forEachEdgeType edgeType iterator
 * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
 * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
 */

/**
     * @private
     * @type {string}
     */

/**
     * {minSpan, maxSpan, minValueSpan, maxValueSpan}
     * @private
     * @type {Object}
     */

/**
     * @readOnly
     * @type {module: echarts/model/Global}
     */

/**
     * @private
     * @type {module: echarts/component/dataZoom/DataZoomModel}
     */

// [0, 500]: arbitrary value, guess axis extent.

// isRestore or isFull

/**
     * Whether the axisProxy is hosted by dataZoomModel.
     *
     * @public
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     * @return {boolean}
     */

/**
     * @return {Array.<number>} Value can only be NaN or finite value.
     */

/**
     * @public
     * @param {number} axisIndex
     * @return {Array} seriesModels
     */

/**
 * @param {string} coordType
 * @return {boolean}
 */

/**
 * Create "each" method to iterate names.
 *
 * @pubilc
 * @param  {Array.<string>} names
 * @param  {Array.<string>=} attrs
 * @return {Function}
 */

/**
     * Only calculate by given range and this._dataExtent, do not change anything.
     *
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     */

// Normalize bound.

// Notice: dataZoom is based either on `percentProp` ('start', 'end') or

// on `valueProp` ('startValue', 'endValue'). The former one is suitable

// for cases that a dataZoom component controls multiple axes with different

// unit or extent, and the latter one is suitable for accurate zoom by pixel

// (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,

// but it is awkward that `percentProp` can not be obtained from `valueProp`

// accurately (because all of values that are overflow the `dataExtent` will

// be calculated to percent '100%'). So we have to use

// `dataZoom.getRangePropMode()` to mark which prop is used.

// `rangePropMode` is updated only when setOption or dispatchAction, otherwise

// it remains its original value.

// Use scale.parse to math round for category or time axis.

// Calculating `percent` from `value` may be not accurate, because

// This calculation can not be inversed, because all of values that

// are overflow the `dataExtent` will be calculated to percent '100%'

// valueWindow[idx] = round(boundValue);

// percentWindow[idx] = round(boundPercent);

/**
     * Notice: reset should not be called before series.restoreData() called,
     * so it is recommanded to be called in "process stage" but not "model init
     * stage".
     *
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */

// Culculate data window and data extent, and record them.

// It is important to get "consistent" extent when more then one axes is

// controlled by a `dataZoom`, otherwise those axes will not be synchronized

// when zooming. But it is difficult to know what is "consistent", considering

// axes have different type or even different meanings (For example, two

// time axes are used to compare data of the same date in different years).

// So basically dataZoom just obtains extent by series.data (in category axis

// extent can be obtained from axis.data).

// Nevertheless, user can set min/max/scale on axes to make extent of axes

// consistent.

// For value axis, if min/max/scale are not set, we just use the extent obtained

// by series data, which may be a little different from the extent calculated by

// `axisHelper.getScaleExtent`. But the different just affects the experience a

// little when zooming. So it will not be fixed until some users require it strongly.

// this.hasSeriesStacked = false;

// each(targetSeries, function (series) {

// var data = series.getData();

// var dataDim = data.mapDimension(this._dimName);

// var stackedDimension = data.getCalculationInfo('stackedDimension');

// if (stackedDimension && stackedDimension === dataDim) {

// this.hasSeriesStacked = true;

// }, this);

// minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

// Update axis setting then.

/**
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */

// Toolbox may has dataZoom injected. And if there are stacked bar chart

// with NaN data, NaN will be filtered and stack will be wrong.

// So we need to force the mode to be set empty.

// In fect, it is not a big deal that do not support filterMode-'filter'

// when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis

// selection" some day, which might need "adapt to data extent on the

// otherAxis", which is disabled by filterMode-'empty'.

// But currently, stack has been fixed to based on value but not index,

// so this is not an issue any more.

// var otherAxisModel = this.getOtherAxisModel();

// if (dataZoomModel.get('$fromToolbox')

//     && otherAxisModel

//     && otherAxisModel.hasSeriesStacked

// ) {

//     filterMode = 'empty';

// filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.

// If both left out and right out, do not filter.

// console.time('select');

// Higher than normal component (z: 2).

// Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.

// Default the first horizontal category axis.

// Default the first vertical category axis.

// Possible values: 'filter' or 'empty' or 'weakFilter'.

// 'filter': data items which are out of window will be removed. This option is

//          applicable when filtering outliers. For each data item, it will be

//          filtered if one of the relevant dimensions is out of the window.

// 'weakFilter': data items which are out of window will be removed. This option

//          is applicable when filtering outliers. For each data item, it will be

//          filtered only if all  of the relevant dimensions are out of the same

//          side of the window.

// 'empty': data items which are out of window will be set to empty.

//          This option is applicable when user should not neglect

//          that there are some data items out of window.

// 'none': Do not filter.

// Taking line chart as an example, line will be broken in

// the filtered points when filterModel is set to 'empty', but

// be connected when set to 'filter'.

// Dispatch action by the fixed rate, avoid frequency.

// default 100. Do not throttle when use null/undefined.

// If animation === true and animationDurationUpdate > 0,

// default value is 100, otherwise 20.

// Start percent. 0 ~ 100

// End percent. 0 ~ 100

// Start value. If startValue specified, start is ignored.

// End value. If endValue specified, end is ignored.

// 0 ~ 100

// The range of dataZoom can not be smaller than that.

// The range of dataZoom can not be larger than that.

/**
         * key like x_0, y_1
         * @private
         * @type {Object}
         */

/**
         * @private
         */

/**
         * key like x_0, y_1
         * @private
         */

/**
         * @readOnly
         */

/**
         * 'percent' or 'value'
         * @private
         */

//FIX #2591

// Disable realtime view update if canvas is not supported.

// start/end has higher priority over startValue/endValue if they

// both set, but we should make chart.setOption({endValue: 1000})

// effective, rather than chart.setOption({endValue: 1000, end: null}).

// Otherwise do nothing and use the merge result.

// Use the first dataZoomModel as the main model of axisProxy.

// If exists, share axisProxy with other dataZoomModels.

// dispose __dzAxisProxy

// Auto set only works for setOption at the first time.

// The following is user's reponsibility. So using merged

// option is OK.

// When user set axisIndex as a empty array, we think that user specify axisIndex

// but do not want use auto mode. Because empty array may be encountered when

// some error occured.

// Find axis that parallel to dataZoom as default.

// Find the first category axis as default. (consider polar)

// 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），

// 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？

// If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,

// dataZoom component auto adopts series that reference to

// both xAxis and yAxis which type is 'value'.

// Find the first axis

// 需要series的xAxisIndex和yAxisIndex都首先自动设置上。

// 例如series.type === scatter时。

// When first time user set throttle, auto throttle ends.

/**
     * @public
     */

/**
     * @public
     * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
     */

/**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
     */

/**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/model/Model} If not found, return null/undefined.
     */

/**
     * If not specified, set to undefined.
     *
     * @public
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     * @param {boolean} [ignoreUpdateRangeUsg=false]
     */

// If only one of 'start' and 'startValue' is not null/undefined, the other

// should be cleared, which enable clear the option.

// If both of them are not set, keep option with the original value, which

// enable use only set start but not set end when calling `dispatchAction`.

// The same as 'end' and 'endValue'.

/**
     * @public
     * @return {Array.<number>} [startPercent, endPercent]
     */

/**
     * @public
     * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
     *
     * @param {string} [axisDimName]
     * @param {number} [axisIndex]
     * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
     */

/**
     * @public
     * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
     *      corresponding to the axisModel
     * @return {module:echarts/component/dataZoom/AxisProxy}
     */

// Find the first hosted axisProxy

// If no hosted axis find not hosted axisProxy.

// Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,

// and the option.start or option.end settings are different. The percentRange

// should follow axisProxy.

// (We encounter this problem in toolbox data zoom.)

/**
     * @return {Array.<string>}
     */

// percentSpecified && valueSpecified

// else remain its original setting.

// Normalize firstly.

// Notice maxSpan and minSpan can be null/undefined.

// Restrict in extent.

// Expand span.

// If minSpan exists, 'cross' is forbinden.

/**
     * Find the first target coordinate system.
     *
     * @protected
     * @return {Object} {
     *                   grid: [
     *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
     *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
     *                       ...
     *                   ],  // cartesians must not be null/undefined.
     *                   polar: [
     *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
     *                       ...
     *                   ],  // polars must not be null/undefined.
     *                   singleAxis: [
     *                       {model: coord0, axisModels: [], coordIndex: 0}
     *                   ]
     */

// ph => placeholder. Using placehoder here because

// deault value can only be drived in view stage.

// Default align to grid rect.

// Background of slider zoom component.

// dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,

// highest priority, remain for compatibility of

// previous version, but not recommended any more.

// border color of the box. For compatibility,

// if dataBackgroundColor is set, borderColor

// is ignored.

// Color of selected area.

// handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.

// handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',

// Percent of the slider height

// Default auto decision.

// Whether disable zoom.

// If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]

// is at left of handleEnds[1] for non-cross case.

/**
         * @private
         * @type {Object}
         */

/**
         * @private
         * @type {string}
         */

/**
         * [0, 100]
         * @private
         */

/**
         * [coord of the first handle, coord of the second handle]
         * @private
         */

/**
         * [length, thick]
         * @private
         * @type {Array.<number>}
         */

/**
         * @private
         * @type {number}
         */

// Notice: this._resetInterval() should not be executed when payload.type

// is 'dataZoom', origin this._range should be maintained, otherwise 'pan'

// or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,

// Why using 'right', because right should be used in vertical,

// and it is better to be consistent for dealing with position param merge.

// vertical

// Replace the placeholder value.

// Transform barGroup.

// Position barGroup

// Click panel, over shadow, below handles.

// Nice extent.

// Should consider axis.min/axis.max when drawing dataShadow.

// 应该使用统一的空判断？还是在list里进行空判断？

// See #4235.

// Attempt to draw data shadow precisely when there are empty value.

// var dataBackgroundModel = dataZoomModel.getModel('dataBackground');

// Find a representative series.

// Frame border.

// Compatitable with previous version

/**
     * @private
     * @param {(number|string)} handleIndex 0 or 1 or 'all'
     * @param {number} delta
     * @return {boolean} changed
     */

// Handles

// Filler

// date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

// Label

// Text should not transform by barGroup.

// Ignore handlers transform

/**
     * @private
     * @param {boolean} showOrHide true: show, false: hide
     */

// Always show when drgging.

// Transform dx, dy to bar coordination.

// Avoid dispatch dataZoom repeatly but range not changed,

// which cause bad visual effect when progressive enabled.

/**
     * This action will be throttled.
     * @private
     */

// Find the grid coresponding to the first axis referred by dataZoom.

// Whether disable this inside zoom.

// Whether disable zoom but only pan.

// Can be: true / false / 'shift' / 'ctrl' / 'alt'.

/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */

/**
 * @alias module:echarts/component/helper/RoamController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 *
 * @param {module:zrender/zrender~ZRender} zr
 */

/**
     * @type {Function}
     */

/**
     * @type {module:zrender}
     */

/**
     * @type {Object}
     */

// Avoid two roamController bind the same handler

/**
     * @param {Function} pointerChecker
     *                   input: x, y
     *                   output: boolean
     */

/**
     * Notice: only enable needed types. For example, if 'zoom'
     * is not needed, 'zoom' should not be enabled, otherwise
     * default mousewheel behaviour (scroll page) will be disabled.
     *
     * @param  {boolean|string} [controlType=true] Specify the control type,
     *                          which can be null/undefined or true/false
     *                          or 'pan/move' or 'zoom'/'scale'
     * @param {Object} [opt]
     * @param {Object} [opt.zoomOnMouseWheel=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
     * @param {Object} [opt.moveOnMouseMove=true] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
     * @param {Object} [opt.moveOnMouseWheel=false] The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
     * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
     */

// Disable previous first

// By default, wheel do not trigger move.

// Only check on mosedown, but not mousemove.

// Mouse can be out of target when mouse moving.

// wheelDelta maybe -0 in chrome mac.

// If both `shouldZoom` and `shouldMove` is true, trigger

// their event both, and the final behavior is determined

// by event listener themselves.

// Convenience:

// Mac and VM Windows on Mac: scroll up: zoom out.

// Windows: scroll up: zoom in.

// FIXME: Should do more test in different environment.

// wheelDelta is too complicated in difference nvironment

// (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),

// although it has been normallized by zrender.

// wheelDelta of mouse wheel is bigger than touch pad.

// When mouse is out of roamController rect,

// default befavoius should not be be disabled, otherwise

// page sliding is disabled, contrary to expectation.

// Also provide behavior checker for event listener, for some case that

// multiple components share one listener.

// settings: {

//     zoomOnMouseWheel

//     moveOnMouseMove

//     moveOnMouseWheel

// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.

// Only create one roam controller for each coordinate system.

// one roam controller might be refered by two inside data zoom

// components (for example, one for x and one for y). When user

// pan or zoom, only dispatch one action for those data zoom

// components.

/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} dataZoomInfo
 * @param {string} dataZoomInfo.coordId
 * @param {Function} dataZoomInfo.containsPoint
 * @param {Array.<string>} dataZoomInfo.allCoordIds
 * @param {string} dataZoomInfo.dataZoomId
 * @param {Object} dataZoomInfo.getRange
 * @param {Function} dataZoomInfo.getRange.pan
 * @param {Function} dataZoomInfo.getRange.zoom
 * @param {Function} dataZoomInfo.getRange.scrollMove
 * @param {boolean} dataZoomInfo.dataZoomModel
 */

// Do clean when a dataZoom changes its target coordnate system.

// Avoid memory leak, dispose all not-used-registered.

// Create if needed.

// Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,

// moveOnMouseWheel, ...) enabled.

// Update reference of dataZoom.

/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */

// DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated

// as string, it is probably revert to reserved word by compress tool. See #7411.

// Prevent default move event by default. If one false, do not prevent. Otherwise

// users may be confused why it does not work when multiple insideZooms exist.

// RoamController will enable all of these functionalities,

// and the final behavior is determined by its event listener

// provided by each inside zoom.

// Consider resize, area should be always updated.

// Update throttle.

/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {string} dataZoomId
 */

/**
 * Key: coordId, value: {dataZoomInfos: [], count, controller}
 * @type {Array.<Object>}
 */

// Mount store on zrender instance, so that we do not

// need to worry about dispose.

/**
 * This action will be throttled.
 */

/**
         * 'throttle' is used in this.dispatchAction, so we save range
         * to avoid missing some 'pan' info.
         * @private
         * @type {Array.<number>}
         */

// Hance the `throttle` util ensures to preserve command order,

// here simply updating range all the time will not cause missing

// any of the the roam change.

// Reset controllers.

/**
     * @this {module:echarts/component/dataZoom/InsideZoomView}
     */

// Restrict range.

// axis.dim === 'y'

// ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);

// ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

// 'angleAxis'

// ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);

// ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

// 'vertical'

// `dataZoomProcessor` will only be performed in needed series. Consider if

// there is a line series and a pie series, it is better not to update the

// line series if only pie series is needed to be updated.

// Consider appendData, where filter should be performed. Because data process is

// in block mode currently, it is not need to worry about that the overallProgress

// execute every frame.

// We calculate window and reset axis here but not in model

// init stage and not after action dispatch handler, because

// reset should be called after seriesData.restoreData.

// Caution: data zoom filtering is order sensitive when using

// percent range and no min/max/scale set on axis.

// For example, we have dataZoom definition:

// [

//      {xAxisIndex: 0, start: 30, end: 70},

//      {yAxisIndex: 0, start: 20, end: 80}

// ]

// In this case, [20, 80] of y-dataZoom should be based on data

// that have filtered by x-dataZoom using range of [30, 70],

// but should not be based on full raw data. Thus sliding

// x-dataZoom will change both ranges of xAxis and yAxis,

// while sliding y-dataZoom will only change the range of yAxis.

// So we should filter x-axis after reset x-axis immediately,

// and then reset y-axis and filter y-axis.

// Fullfill all of the range props so that user

// is able to get them from chart.getOption().

/**
 * DataZoom component entry
 */

// right

// bottom

// Keep for diff.

/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */

// Render background after group is layout

// Adjust icon title positions to avoid them out of screen

// May be background element

// Create

/* global Uint8Array */

// If feature does not exsit.

// Should not reuse above hoverStyle, which might be modified.

// updateLayout: function (toolboxModel, ecModel, api, payload) {

//     zrUtil.each(this._features, function (feature) {

//         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);

// Default use option.backgroundColor

// backgroundColor: '#fff',

// Chrome and Firefox

// IE

// Icon group

// `line`, `bar`, `stack`, `tiled`

// Preserve data related option

// Not supported magicType

// PENDING If merge original option?

// Modify boundaryGap

/**
 * @param {module:echarts/model/Global}
 * @return {Object}
 * @inner
 */

/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 * @param {module:echarts/model/Global} ecModel
 * @return {Object}
 * @inner
 */

/**
 * Assemble content of series on cateogory axis
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */

// Assemble table content

/**
 * Assemble content of other series
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */

/**
 * If a block is tsv format
 */

/**
 * @param {string} tsv
 * @return {Object}
 */

/**
 * @param {string} str
 * @param {Array.<Object>} blockMetaList
 * @return {Object}
 * @inner
 */

/**
 * @param {string} str
 * @return {Array.<Object>}
 * @inner
 */

// First item is name

/**
 * @alias {module:echarts/component/toolbox/feature/DataView}
 * @constructor
 * @param {module:echarts/model/Model} model
 */

// Create elements

// Use default textarea

// http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea

// get caret position/selection

// set textarea value to: text before caret + tab + text after caret

// put caret at right position again

// prevent the focus lose

// New created series

// Geuss the series type

// Default is scatter

/**
 * @alias module:echarts/component/helper/BrushController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 * @event module:echarts/component/helper/BrushController#brush
 *        params:
 *            areas: Array.<Array>, coord relates to container group,
 *                                    If no container specified, to global.
 *            opt {
 *                isEnd: boolean,
 *                removeOnClick: boolean
 *            }
 *
 * @param {module:zrender/zrender~ZRender} zr
 */

/**
     * @type {module:zrender/zrender~ZRender}
     * @private
     */

/**
     * Only for drawing (after enabledBrush).
     *     'line', 'rect', 'polygon' or false
     *     If passing false/null/undefined, disable brush.
     *     If passing 'auto', determined by panel.defaultBrushType
     * @private
     * @type {string}
     */

/**
     * Only for drawing (after enabledBrush).
     *
     * @private
     * @type {Object}
     */

/**
     * @private
     * @type {Array.<nubmer>}
     */

/**
     * @private
     * @type {Array}
     */

/**
     * @private
     * @type {moudule:zrender/container/Group}
     */

/**
     * `true` means global panel
     * @private
     * @type {module:zrender/container/Group|boolean}
     */

// return target panel or `true` (means global panel)

// Global panel

// Return a panel or true

// User may give cover without coord sys info,

// which is then treated as global panel.

// x range

/**
     * If set to null/undefined/false, select disabled.
     * @param {Object} brushOption
     * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
     *                          If passing false/null/undefined, disable brush.
     *                          If passing 'auto', determined by panel.defaultBrushType.
     *                              ('auto' can not be used in global panel)
     * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
     * @param {boolean} [brushOption.transformable=true]
     * @param {boolean} [brushOption.removeOnClick=false]
     * @param {Object} [brushOption.brushStyle]
     * @param {number} [brushOption.brushStyle.width]
     * @param {number} [brushOption.brushStyle.lineWidth]
     * @param {string} [brushOption.brushStyle.stroke]
     * @param {string} [brushOption.brushStyle.fill]
     * @param {number} [brushOption.z]
     */

// Consider roam, which takes globalPan too.

/**
     * @param {Array.<Object>} panelOpts If not pass, it is global brush.
     *        Each items: {
     *            panelId, // mandatory.
     *            clipPath, // mandatory. function.
     *            isTargetByCursor, // mandatory. function.
     *            defaultBrushType, // optional, only used when brushType is 'auto'.
     *            getLinearBrushOtherExtent, // optional. function.
     *        }
     */

/**
     * @param {Object} [opt]
     * @return {boolean} [opt.enableGlobalPan=false]
     */

/**
     * Update covers.
     * @param {Array.<Object>} brushOptionList Like:
     *        [
     *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
     *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
     *            ...
     *        ]
     *        `brushType` is required in each cover info. (can not be 'auto')
     *        `id` is not mandatory.
     *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
     *        If brushOptionList is null/undefined, all covers removed.
     */

// Consider setOption in event listener of brushSelect,

// where updating cover when creating should be forbiden.

// container may 'removeAll' outside.

// In case some browser do not support globalOut,

// and release mose out side the browser.

// Check active

// Check whether in covers.

// Use cursor style set on cover.

// trigger event shoule be at final, after procedure will be nested.

/**
 * key: brushType
 * @type {Object}
 */

// Do not use graphic.Polygon because graphic.Polyline do not close the

// border of the shape when drawing, which is a better experience for user.

// Use graphic.Polygon close the shape.

// If brushWidth not specified, fit the panel.

/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

// If model is axisModel, it works only if it is injected with coordinateSystem.

// Consider width/height is negative.

/**
 * [option in constructor]:
 * {
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 * }
 *
 *
 * [targetInfo]:
 *
 * There can be multiple axes in a single targetInfo. Consider the case
 * of `grid` component, a targetInfo represents a grid which contains one or more
 * cartesian and one or more axes. And consider the case of parallel system,
 * which has multiple axes in a coordinate system.
 * Can be {
 *     panelId: ...,
 *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
 *     coordSyses: all cartesians.
 *     gridModel: <grid component>
 *     xAxes: correspond to coordSyses on index
 *     yAxes: correspond to coordSyses on index
 * }
 * or {
 *     panelId: ...,
 *     coordSys: <geo coord sys>
 *     coordSyses: [<geo coord sys>]
 *     geoModel: <geo component>
 * }
 *
 *
 * [panelOpt]:
 *
 * Make from targetInfo. Input to BrushController.
 * {
 *     panelId: ...,
 *     rect: ...
 * }
 *
 *
 * [area]:
 *
 * Generated by BrushController or user input.
 * {
 *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
 *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 *     range: pixel range.
 *     coordRange: representitive coord range (the first one of coordRanges).
 *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
 * }
 */

/**
 * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
 *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} [opt]
 * @param {Array.<string>} [opt.include] include coordinate system types.
 */

// area.coordRange is the first of area.coordRanges

// In 'category' axis, coord to pixel is not reversible, so we can not

// rebuild range by coordRange accrately, which may bring trouble when

// brushing only one item. So we use __rangeOffset to rebuilding range

// by coordRange. And this it only used in brush component so it is no

// need to be adapted to coordRanges.

// convert coordRange to global range and set panelId.

// (1) area.range shoule always be calculate from coordRange but does

// not keep its original value, for the sake of the dataZoom scenario,

// where area.coordRange remains unchanged but area.range may be changed.

// (2) Only support converting one coordRange to pixel range in brush

// component. So do not consider `coordRanges`.

// (3) About __rangeOffset, see comment above.

// We have to process scale caused by dataZoom manually,

// although it might be not accurate.

// Check whether area is bound in coord, and series do not belong to that coord.

// If do not do this check, some brush (like lineX) will controll all axes.

/**
 * If return Object, a coord found.
 * If reutrn true, global found.
 * Otherwise nothing found.
 *
 * @param {Object} area
 * @param {Array} targetInfoList
 * @return {Object|boolean}
 */

// Use the first one as the representitive coordSys.

// grid

// geo

// grid is not Transformable.

// geo roam and zoom transform

/**
 * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 * @type {Array.<Object>}
 */

// Use dataZoomSelect

/**
     * @private
     * @type {module:echarts/component/helper/BrushController}
     */

// `zoom`, `back`

// FIXME user customized?

/**
 * @param {module:echarts/model/Global} ecModel
 * @return {number} records. always >= 1.
 */

/**
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} snapshot
 */

// Find top for all dataZoom.

/**
 * @param {module:echarts/model/Global} ecModel
 */

// Compatible with previous setting: null => all axis, false => no axis.

/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
 */

// If previous dataZoom can not be found,

// complete an range with current range.

// No origin range set, create one by current range.

// Convert from hash map to array.

// Create special dataZoom option for select

// FIXME consider the case of merge option, where axes options are not exists.

// Assume there is only one toolbox

// FIXME: If add dataZoom when setOption in merge mode,

// no axis info to be added. See `test/dataZoom-extreme.html`

// Try not to modify model, because it is not merged yet.

// Id for merge mapping.

// Only support one axis now.

// From raphael

// http://www.w3.org/TR/NOTE-VML

// TODO Use proxy like svg instead of overwrite brush methods

// z 的取值范围为 [0, 1000]

// Stroke must have lineWidth

// FIXME Remove before updating, or set `colors` will throw error

// TODO pattern

// Modified from excanvas

// The angle should be a non-negative number.

// Very small angles produce an unexpected result because they are

// converted to a scientific notation string.

// Percent in bounding rect

// We need to sort the color stops in ascending order by offset,

// otherwise IE won't interpret it correctly.

// Color and alpha list of first and last stop

// When colors attribute is used, the meanings of opacity and o:opacity2

// are reversed.

// FIXME g_o_:opacity ?

// FIXME Change from Gradient fill to color fill

// if (style.lineJoin != null) {

//     el.joinstyle = style.lineJoin;

// if (style.miterLimit != null) {

//     el.miterlimit = style.miterLimit * Z;

// if (style.lineCap != null) {

//     el.endcap = style.lineCap;

// Rewrite the original path method

// Determinant of this.m_ means how much the area is enlarged by the

// Extract SRT from matrix

// var psi = data[i++];

// IE won't render arches drawn counter clockwise if x0 == x1.

// Offset x0 by 1/80 of a pixel. Use something

// that can be represented in binary

// Avoid case draw full circle

// x1, y0

// x0, y1

// FIXME Update xi, yi

// 不 round 会非常慢

// Append to root

// Text

// FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错

// return img instanceof Image;

// get the original size

// and remove overides

// Caching image original width, height and src

// FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。

// vmlEl = vmlCore.createNode('group');

// If filters are necessary (rotation exists), create them

// filters are bog-slow, so only create them if abbsolutely necessary

// The following check doesn't account for skews (which don't exist

// in the canvas spec (yet) anyway.

// From excanvas

// FIXME DXImageTransform 在 IE11 的兼容模式下不起作用

// Needs know image original width and height

// Adjust image width and height to fit the ratio destinationSize / sourceSize

/***************************************************
     * TEXT
     **************************************************/

// Overwrite measure text method

// Ignore failures to set to invalid font.

// Don't use innerHTML or innerText because they allow markup/whitespace.

// In case Displayable has been mixed in RectText

// Convert rich text to plain text. Rich text is not supported in

// IE8-, but tags in rich text template will be removed.

// Clear cache

// Ignore transform for text in other element

// Force baseline 'middle'

// var fontSize = fontStyle.size;

// 1.75 is an arbitrary number, as there is no info about the text baseline

// switch (baseline) {

// case 'hanging':

// case 'top':

//     y += fontSize / 1.75;

//     break;

//     case 'middle':

//         break;

//     default:

//     // case null:

//     // case 'alphabetic':

//     // case 'ideographic':

//     // case 'bottom':

//         y -= fontSize / 2.25;

// switch (align) {

//     case 'left':

//     case 'center':

//         x -= textRect.width / 2;

//     case 'right':

//         x -= textRect.width;

// case 'end':

// align = elementStyle.direction == 'ltr' ? 'right' : 'left';

// break;

// case 'start':

// align = elementStyle.direction == 'rtl' ? 'right' : 'left';

// default:

//     align = 'left';

// 这里是在前面 appendChild 保证顺序的前提下

// FIXME Why here is not cammel case

// Align 'center' seems wrong

// Text position

// Left top point as origin

// Error font format

// Attached to root

/**
 * VML Painter.
 *
 * @module zrender/vml/Painter
 */

/**
 * @alias module:zrender/vml/Painter
 */

// http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx

// Modify storage

// Displayable already has a vml node

/**
     * 刷新
     */

// Set as already invisible

// Detached from document at first time

// to avoid page refreshing too many times

// FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变

// Unsupported methods

// Not supported methods

// 1. shadow

// 2. Image: sx, sy, sw, sh

// Don't set attribute for gradient, since it need new dom nodes

/**
         * FIXME:
         * This is a temporary fix for Chrome's clipping bug
         * that happens when a clip-path is referring another one.
         * This fix should be used before Chrome's bug is fixed.
         * For an element that has clip-path, and fill is none,
         * set it to be "rgba(0, 0, 0, 0.002)" will hide the element.
         * Otherwise, it will show black fill color.
         * 0.002 is used because this won't work for alpha values smaller
         * than 0.002.
         *
         * See
         * https://bugs.chromium.org/p/chromium/issues/detail?id=659790
         * for more information.
         */

// stroke then fill for text; fill then stroke for others

/***************************************************
 * PATH
 **************************************************/

// It will not draw if start point and end point are exactly the same

// We need to shift the end point with a small value

// FIXME A better way to draw circle ?

// Move to (x0, y0) only when CMD.A comes at the

// first position of a shape.

// For instance, when drawing a ring, CMD.A comes

// after CMD.M, so it's unnecessary to move to

// (x0, y0).

// FIXME Ellipse

// PENDING With scale

// Ignore illegal path, which may happen such in out-of-range

// data in Calendar series.

/***************************************************
 * IMAGE
 **************************************************/

// Caching image src

// Make baseline top

// Transform text with element

// Text rotation, but no element transform

// Apply textRotate to element matrix

// Font may affect position of each tspan elements

// Remove unsed tspan elements

// Update span x and y

// Myers' Diff Algorithm

// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js

// Common case

// 强制设置 textPosition

// Allow subclasses to massage the input prior to running

// Identity per the equality and tokenizer

// Main worker method. checks all permutations of a given edit length for acceptance.

// No one else is going to attempt to use this value, clear it

// If we have hit the end of both strings, then we are done

// Select the diagonal that we want to branch from. We select the prior

// path whose position in the new string is the farthest from the origin

// and does not pass the bounds of the diff graph

// No need to clone, we've pulled it from the list

// Otherwise track this path as a potential candidate and continue.

// If this path is a terminal then prune

// We need to clone here as the component clone operation is just

// as shallow array clone

/**
 * Manages elements that can be defined in <defs> in SVG,
 * e.g., gradients, clip path, etc.
 *
 * @class
 * @param {number}          zrId      zrender instance id
 * @param {SVGElement}      svgRoot   root of SVG document
 * @param {string|string[]} tagNames  possible tag names
 * @param {string}          markLabel label name to make if the element
 *                                    is used
 */

/**
 * @file Manages SVG gradient elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG gradient elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */

/**
 * @file Manages SVG clipPath elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG clipPath elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */

/**
 * @file Manages SVG shadow elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG shadow elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */

// TODO: textBoxShadowBlur is not supported yet

/**
 * SVG Painter
 * @module zrender/svg/Painter
 */

/**
 * @alias module:zrender/svg/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */

/**
 * Get the <defs> tag for svgRoot; optionally creates one if not exists.
 *
 * @param {boolean} isForceCreating if need to create when not exists
 * @return {SVGDefsElement} SVG <defs> element, null if it doesn't
 * exist and isForceCreating is false
 */

// Not exist

// Create new tag

// IE doesn't support contains method

/**
 * Update DOM element if necessary.
 *
 * @param {Object|string} element style element. e.g., for gradient,
 *                                it may be '#ccc' or {type: 'linear', ...}
 * @param {Function|undefined} onUpdate update callback
 */

// Update DOM

// No previous dom, create new

/**
 * Add gradient dom to defs
 *
 * @param {SVGElement} dom DOM to be added to <defs>
 */

/**
 * Remove DOM of a given element.
 *
 * @param {SVGElement} element element to remove dom
 */

/**
 * Get DOMs of this element.
 *
 * @return {HTMLDomElement} doms of this defineable elements in <defs>
 */

// No dom when defs is not defined

// Note that tags is HTMLCollection, which is array-like

// rather than real array.

// So `doms.concat(tags)` add tags as one object.

/**
 * Mark DOMs to be unused before painting, and clear unused ones at the end
 * of the painting.
 */

/**
 * Mark a single DOM to be used.
 *
 * @param {SVGElement} dom DOM to mark
 */

/**
 * Remove unused DOMs defined in <defs>
 */

// Remove gradient

/**
 * Get SVG proxy.
 *
 * @param {Displayable} displayable displayable element
 * @return {Path|Image|Text} svg proxy of given element
 */

/**
 * Get text SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element of text
 */

/**
 * Get SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element
 */

/**
 * Create new gradient DOM for fill or stroke if not exist,
 * but will not update gradient if exists.
 *
 * @param {SvgElement}  svgElement   SVG element to paint
 * @param {Displayable} displayable  zrender displayable element
 */

// Gradient exists

// _dom is no longer in defs, recreate

// New dom

/**
 * Add a new gradient tag in <defs>
 *
 * @param   {Gradient} gradient zr gradient instance
 * @return {SVGLinearGradientElement | SVGRadialGradientElement}
 *                            created DOM
 */

// Set dom id with gradient id, since each gradient instance

// will have no more than one dom element.

// id may exists before for those dirty elements, in which case

// id should remain the same, and other attributes should be

// updated.

/**
 * Update gradient.
 *
 * @param {Gradient} gradient zr gradient instance
 */

// Gradient type is not changed, update gradient

// Remove and re-create if type is changed

/**
 * Update gradient dom
 *
 * @param {Gradient} gradient zr gradient instance
 * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom
 *                            DOM to update
 */

// x1, x2, y1, y2 in range of 0 to canvas width or height

// x1, x2, y1, y2 in range of 0 to 1

// Remove color stops if exists

// Add color stops

// Fix Safari bug that stop-color not recognizing alpha #9014

// stop-color cannot be color, since:

// The opacity value used for the gradient calculation is the

// *product* of the value of stop-opacity and the opacity of the

// value of stop-color.

// See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty

// Store dom element in gradient, to avoid creating multiple

// dom instances for the same gradient element

/**
 * Mark a single gradient to be used
 *
 * @param {Displayable} displayable displayable element
 */

/**
 * Update clipPath.
 *
 * @param {Displayable} displayable displayable element
 */

// Make another clipPath for text, since it's transform

// matrix is not the same with svgElement

/**
 * Create an SVGElement of displayable and create a <clipPath> of its
 * clipPath
 *
 * @param {Displayable} parentEl  parent element
 * @param {ClipPath[]}  clipPaths clipPaths of parent element
 * @param {boolean}     isText    if parent element is Text
 */

// Has clipPath, create <clipPath> with the first clipPath

// Use a dom that is already in <defs>

// This happens when set old clipPath that has

// been previously removed

// New <clipPath>

// Build path and add to <clipPath>

/**
             * If a clipPath has a parent with transform, the transform
             * of parent should not be considered when setting transform
             * of clipPath. So we need to transform back from parent's
             * transform, which is done by multiplying parent's inverse
             * transform.
             */

// Store old transform

// Transform back from parent, and brush path

// Set back transform of clipPath

/**
         * Use `cloneNode()` here to appendChild to multiple parents,
         * which may happend when Text and other shapes are using the same
         * clipPath. Since Text will create an extra clipPath DOM due to
         * different transform rules.
         */

// Make the other clipPaths recursively

// No clipPath

/**
 * Mark a single clipPath to be used
 *
 * @param {Displayable} displayable displayable element
 */

/**
 * Create new shadow DOM for fill or stroke if not exist,
 * but will not update shadow if exists.
 *
 * @param {SvgElement}  svgElement   SVG element to paint
 * @param {Displayable} displayable  zrender displayable element
 */

// Create dom in <defs> if not exists

// _shadowDom is no longer in defs, recreate

/**
 * Add a new shadow tag in <defs>
 *
 * @param {Displayable} displayable  zrender displayable element
 * @return {SVGFilterElement} created DOM
 */

// Set dom id with shadow id, since each shadow instance

/**
 * Update shadow.
 *
 * @param {Displayable} displayable  zrender displayable element
 */

// Remove shadow

/**
 * Remove DOM and clear parent filter
 */

/**
 * Update shadow dom
 *
 * @param {Displayable} displayable  zrender displayable element
 * @param {SVGFilterElement} dom DOM to update
 */

// Divide by two here so that it looks the same as in canvas

// See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur

// Fix filter clipping problem

// Store dom element in shadow, to avoid creating multiple

// dom instances for the same shadow element

/**
 * Mark a single shadow to be used
 *
 * @param {Displayable} displayable displayable element
 */

// TODO gradient

// Update gradient and shadow

// First do remove, in case element moved to the head and do remove

// after add

// Insert text

// Set width by 'svgRoot.width = width' is invalid

// Unsuppoted methods

/**
 * @param {HTMLElement} dom
 * @param {Object} [theme]
 * @param {Object} opts
 * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
 * @param {string} [opts.renderer] Currently only 'canvas' is supported.
 * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
 *                              Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
 *                               Can be 'auto' (the same as null/undefined)
 */

// Check version

/**
 * @return {string|Array.<module:echarts~ECharts>} groupId
 */

// Is array of charts

// If any chart has group

// Try to treat as dom

/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */

/**
 * @param {string} mapName
 * @param {Array.<Object>|Object|string} geoJson
 * @param {Object} [specialAreas]
 *
 * @example GeoJSON
 *     $.get('USA.json', function (geoJson) {
 *         echarts.registerMap('USA', geoJson);
 *         // Or
 *         echarts.registerMap('USA', {
 *             geoJson: geoJson,
 *             specialAreas: {}
 *         })
 *     });
 *
 *     $.get('airport.svg', function (svg) {
 *         echarts.registerMap('airport', {
 *             svg: svg
 *         }
 *     });
 *
 *     echarts.registerMap('eu', [
 *         {svg: eu-topographic.svg},
 *         {geoJSON: eu.json}
 *     ])
 */

/**
 * @param {string} mapName
 * @return {Object}
 */

// For backward compatibility, only return the first one.
